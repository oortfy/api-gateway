
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">api-gateway/cmd/api/main.go (0.0%)</option>
				
				<option value="file1">api-gateway/internal/auth/auth.go (0.0%)</option>
				
				<option value="file2">api-gateway/internal/config/config.go (0.0%)</option>
				
				<option value="file3">api-gateway/internal/config/routes.go (0.0%)</option>
				
				<option value="file4">api-gateway/internal/handlers/handlers.go (0.0%)</option>
				
				<option value="file5">api-gateway/internal/middleware/auth.go (0.0%)</option>
				
				<option value="file6">api-gateway/internal/middleware/cache.go (0.0%)</option>
				
				<option value="file7">api-gateway/internal/middleware/cors.go (0.0%)</option>
				
				<option value="file8">api-gateway/internal/middleware/header_transform.go (0.0%)</option>
				
				<option value="file9">api-gateway/internal/middleware/metrics.go (0.0%)</option>
				
				<option value="file10">api-gateway/internal/middleware/ratelimit.go (0.0%)</option>
				
				<option value="file11">api-gateway/internal/middleware/retry.go (0.0%)</option>
				
				<option value="file12">api-gateway/internal/middleware/tracing.go (0.0%)</option>
				
				<option value="file13">api-gateway/internal/middleware/url_rewrite.go (0.0%)</option>
				
				<option value="file14">api-gateway/internal/proxy/circuit_breaker.go (0.0%)</option>
				
				<option value="file15">api-gateway/internal/proxy/http_proxy.go (0.0%)</option>
				
				<option value="file16">api-gateway/internal/proxy/load_balancer.go (0.0%)</option>
				
				<option value="file17">api-gateway/internal/proxy/ws_proxy.go (0.0%)</option>
				
				<option value="file18">api-gateway/internal/server/server.go (0.0%)</option>
				
				<option value="file19">api-gateway/pkg/logger/logger.go (0.0%)</option>
				
				<option value="file20">api-gateway/tests/testutils/mocks.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "flag"
        "os"
        "os/signal"
        "path/filepath"
        "syscall"
        "time"

        "api-gateway/internal/config"
        "api-gateway/internal/server"
        "api-gateway/pkg/logger"
)

func main() <span class="cov0" title="0">{
        // Parse command line flags
        configPath := flag.String("config", getEnv("CONFIG_PATH", "configs/config.yaml"), "path to config file")
        routesPath := flag.String("routes", getEnv("ROUTES_PATH", "configs/routes.yaml"), "path to routes file")
        flag.Parse()

        // Initialize logger
        log := logger.NewLogger()
        log.Info("Starting API Gateway...")

        // Load configuration
        cfg, err := config.LoadConfig(*configPath)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Failed to load config", logger.Error(err))
        }</span>

        // Load routes configuration
        <span class="cov0" title="0">routes, err := config.LoadRoutes(*routesPath)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Failed to load routes", logger.Error(err))
        }</span>

        // Log configuration file paths
        <span class="cov0" title="0">log.Info("Configuration loaded",
                logger.String("config_path", *configPath),
                logger.String("routes_path", *routesPath),
        )

        // Create and start server
        srv := server.NewServer(cfg, routes, log)
        go func() </span><span class="cov0" title="0">{
                if err := srv.Start(); err != nil </span><span class="cov0" title="0">{
                        log.Fatal("Failed to start server", logger.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">log.Info("API Gateway is running", logger.String("address", cfg.Server.Address))

        // Graceful shutdown
        quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
        &lt;-quit

        log.Info("Shutting down API Gateway...")

        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        if err := srv.Stop(ctx); err != nil </span><span class="cov0" title="0">{
                log.Fatal("Server forced to shutdown", logger.Error(err))
        }</span>

        <span class="cov0" title="0">log.Info("API Gateway has been shutdown gracefully")</span>
}

// getEnv retrieves environment variable or returns the provided default value
func getEnv(key, defaultValue string) string <span class="cov0" title="0">{
        value := os.Getenv(key)
        if value == "" </span><span class="cov0" title="0">{
                return defaultValue
        }</span>

        // Convert to absolute path if not already
        <span class="cov0" title="0">if !filepath.IsAbs(value) </span><span class="cov0" title="0">{
                if absPath, err := filepath.Abs(value); err == nil </span><span class="cov0" title="0">{
                        return absPath
                }</span>
        }

        <span class="cov0" title="0">return value</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package auth

import (
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "strings"
        "time"

        "api-gateway/internal/config"
        "api-gateway/pkg/logger"

        "github.com/golang-jwt/jwt/v4"
)

var (
        ErrNoToken      = errors.New("no authentication token provided")
        ErrInvalidToken = errors.New("invalid authentication token")
        ErrExpiredToken = errors.New("token has expired")
        ErrForbidden    = errors.New("forbidden: insufficient permissions")
        ErrAuthFailed   = errors.New("authentication failed")
)

// AuthService provides authentication functionality
type AuthService struct {
        config *config.AuthConfig
        log    logger.Logger
        client *http.Client
}

// APIKeyResponse represents the response from the API key validation endpoint
type APIKeyResponse struct {
        Valid       bool     `json:"valid"`
        UserID      string   `json:"user_id"`
        TenantID    string   `json:"tenant_id"`
        Role        string   `json:"role"`
        Permissions []string `json:"permissions"`
        AuthType    string   `json:"auth_type"`
}

// JWTClaims represents the custom claims for the JWT
type JWTClaims struct {
        Role string `json:"role"`
        jwt.RegisteredClaims
}

// NewAuthService creates a new authentication service
func NewAuthService(config *config.AuthConfig, log logger.Logger) *AuthService <span class="cov0" title="0">{
        return &amp;AuthService{
                config: config,
                log:    log,
                client: &amp;http.Client{
                        Timeout: 5 * time.Second,
                },
        }
}</span>

// ValidateToken validates the provided authentication token
// It first tries to validate as a JWT token, if that fails, it tries as an API token
func (a *AuthService) ValidateToken(r *http.Request, allowedRoles []string) (bool, error) <span class="cov0" title="0">{
        // Try JWT validation first
        jwtToken := a.extractJWTToken(r)
        if jwtToken != "" </span><span class="cov0" title="0">{
                valid, _, err := a.validateJWT(jwtToken)
                if err == nil &amp;&amp; valid </span><span class="cov0" title="0">{
                        // Skip role checking - any authenticated user is allowed
                        return true, nil
                }</span>

                // If it's a definite error like malformed JWT, return immediately
                <span class="cov0" title="0">if err != nil &amp;&amp; !errors.Is(err, ErrNoToken) </span><span class="cov0" title="0">{
                        a.log.Debug("JWT validation failed", logger.Error(err))
                        return false, err
                }</span>
        }

        // Try API token validation next
        <span class="cov0" title="0">apiToken := a.extractAPIToken(r)
        if apiToken != "" </span><span class="cov0" title="0">{
                valid, _, err := a.validateAPIToken(apiToken)
                if err != nil </span><span class="cov0" title="0">{
                        a.log.Debug("API token validation failed", logger.Error(err))
                        return false, err
                }</span>
                <span class="cov0" title="0">if valid </span><span class="cov0" title="0">{
                        // Skip role checking - any authenticated user is allowed
                        return true, nil
                }</span>
        }

        // Neither token type was valid
        <span class="cov0" title="0">if jwtToken == "" &amp;&amp; apiToken == "" </span><span class="cov0" title="0">{
                return false, ErrNoToken
        }</span>

        <span class="cov0" title="0">return false, ErrAuthFailed</span>
}

// extractJWTToken extracts JWT token from the Authorization header
func (a *AuthService) extractJWTToken(r *http.Request) string <span class="cov0" title="0">{
        authHeader := r.Header.Get(a.config.JWTHeader)
        if authHeader == "" </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Check if the header has the "Bearer " prefix
        <span class="cov0" title="0">parts := strings.SplitN(authHeader, " ", 2)
        if len(parts) != 2 || parts[0] != "Bearer" </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">return parts[1]</span>
}

// extractAPIToken extracts API token from the header
func (a *AuthService) extractAPIToken(r *http.Request) string <span class="cov0" title="0">{
        return r.Header.Get(a.config.APIKeyHeader)
}</span>

// validateJWT validates a JWT token and returns the associated role
func (a *AuthService) validateJWT(tokenString string) (bool, string, error) <span class="cov0" title="0">{
        token, err := jwt.ParseWithClaims(tokenString, &amp;JWTClaims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                // Validate the algorithm
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov0" title="0">return []byte(a.config.JWTSecret), nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, jwt.ErrTokenExpired) </span><span class="cov0" title="0">{
                        return false, "", ErrExpiredToken
                }</span>
                <span class="cov0" title="0">return false, "", ErrInvalidToken</span>
        }

        <span class="cov0" title="0">if claims, ok := token.Claims.(*JWTClaims); ok &amp;&amp; token.Valid </span><span class="cov0" title="0">{
                return true, claims.Role, nil
        }</span>

        <span class="cov0" title="0">return false, "", ErrInvalidToken</span>
}

// validateAPIToken validates an API token by making a request to the validation endpoint
func (a *AuthService) validateAPIToken(token string) (bool, string, error) <span class="cov0" title="0">{
        if a.config.APIKeyValidationURL == "" </span><span class="cov0" title="0">{
                return false, "", errors.New("API key validation URL not configured")
        }</span>

        // Create a new HTTP request according to the specified format
        <span class="cov0" title="0">req, err := http.NewRequest(http.MethodPost, a.config.APIKeyValidationURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return false, "", err
        }</span>

        // Set the x-api-key header instead of Authorization header
        <span class="cov0" title="0">req.Header.Set("x-api-key", token)
        req.Header.Set("accept", "application/json")

        resp, err := a.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return false, "", fmt.Errorf("API key validation request failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        // Check if the response status code is successful
        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return false, "", fmt.Errorf("API key validation failed with status: %d", resp.StatusCode)
        }</span>

        // Parse the response body
        <span class="cov0" title="0">var apiKeyResp APIKeyResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;apiKeyResp); err != nil </span><span class="cov0" title="0">{
                return false, "", fmt.Errorf("failed to decode API key validation response: %w", err)
        }</span>

        <span class="cov0" title="0">if !apiKeyResp.Valid </span><span class="cov0" title="0">{
                return false, "", errors.New("invalid API key")
        }</span>

        // Return the validation result and role
        <span class="cov0" title="0">return true, apiKeyResp.Role, nil</span>
}

// checkRole checks if the provided role is in the list of allowed roles
func (a *AuthService) checkRole(role string, allowedRoles []string) (bool, error) <span class="cov0" title="0">{
        // If no specific roles are required, any authenticated user is allowed
        if len(allowedRoles) == 0 </span><span class="cov0" title="0">{
                return true, nil
        }</span>

        // Check if "any" is in the allowed roles list - this is a wildcard that matches any role
        <span class="cov0" title="0">for _, allowedRole := range allowedRoles </span><span class="cov0" title="0">{
                if allowedRole == "any" </span><span class="cov0" title="0">{
                        return true, nil
                }</span>
        }

        // Check if the user's specific role is allowed
        <span class="cov0" title="0">for _, allowedRole := range allowedRoles </span><span class="cov0" title="0">{
                if allowedRole == role </span><span class="cov0" title="0">{
                        return true, nil
                }</span>
        }

        <span class="cov0" title="0">return false, ErrForbidden</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package config

import (
        "fmt"
        "io"
        "os"
        "strings"

        "gopkg.in/yaml.v3"
)

// Config contains all configuration for the application
type Config struct {
        Server   ServerConfig   `yaml:"server"`
        Auth     AuthConfig     `yaml:"auth"`
        Logging  LoggingConfig  `yaml:"logging"`
        Security SecurityConfig `yaml:"security"`
        Cache    CacheConfig    `yaml:"cache"`
        Cors     CorsConfig     `yaml:"cors"`
        Metrics  MetricsConfig  `yaml:"metrics"`
        Tracing  TracingConfig  `yaml:"tracing"`
}

// ServerConfig contains server configuration
type ServerConfig struct {
        Address           string `yaml:"address"`
        ReadTimeout       int    `yaml:"read_timeout"`
        WriteTimeout      int    `yaml:"write_timeout"`
        IdleTimeout       int    `yaml:"idle_timeout"`
        MaxHeaderBytes    int    `yaml:"max_header_bytes"`
        EnableHTTP2       bool   `yaml:"enable_http2"`
        EnableCompression bool   `yaml:"enable_compression"`
}

// AuthConfig contains authentication configuration
type AuthConfig struct {
        JWTSecret           string `yaml:"jwt_secret"`
        JWTExpiryHours      int    `yaml:"jwt_expiry_hours"`
        APIKeyValidationURL string `yaml:"api_key_validation_url"`
        APIKeyHeader        string `yaml:"api_key_header"`
        JWTHeader           string `yaml:"jwt_header"`
}

// LoggingConfig contains logging configuration
type LoggingConfig struct {
        Level        string `yaml:"level"`
        Format       string `yaml:"format"`
        Output       string `yaml:"output"`
        EnableAccess bool   `yaml:"enable_access_log"`
}

// SecurityConfig contains security configuration
type SecurityConfig struct {
        TLS                      TLSConfig `yaml:"tls"`
        EnableXSSProtection      bool      `yaml:"enable_xss_protection"`
        EnableFrameDeny          bool      `yaml:"enable_frame_deny"`
        EnableContentTypeNosniff bool      `yaml:"enable_content_type_nosniff"`
        EnableHSTS               bool      `yaml:"enable_hsts"`
        HSTSMaxAge               int       `yaml:"hsts_max_age"`
        TrustedProxies           []string  `yaml:"trusted_proxies"`
        IPWhitelist              []string  `yaml:"ip_whitelist"`
        IPBlacklist              []string  `yaml:"ip_blacklist"`
        MaxBodySize              int64     `yaml:"max_body_size"`
}

// TLSConfig contains TLS configuration
type TLSConfig struct {
        Enabled          bool     `yaml:"enabled"`
        CertFile         string   `yaml:"cert_file"`
        KeyFile          string   `yaml:"key_file"`
        MinVersion       string   `yaml:"min_version"`
        MaxVersion       string   `yaml:"max_version"`
        CipherSuites     []string `yaml:"cipher_suites"`
        CurvePreferences []string `yaml:"curve_preferences"`
}

// CacheConfig contains caching configuration
type CacheConfig struct {
        Enabled       bool     `yaml:"enabled"`
        DefaultTTL    int      `yaml:"default_ttl"`
        MaxTTL        int      `yaml:"max_ttl"`
        MaxSize       int      `yaml:"max_size"`
        IncludeHost   bool     `yaml:"include_host"`
        VaryHeaders   []string `yaml:"vary_headers"`
        PurgeEndpoint string   `yaml:"purge_endpoint"`
}

// CorsConfig contains CORS configuration
type CorsConfig struct {
        Enabled          bool     `yaml:"enabled"`
        AllowAllOrigins  bool     `yaml:"allow_all_origins"`
        AllowedOrigins   []string `yaml:"allowed_origins"`
        AllowedMethods   []string `yaml:"allowed_methods"`
        AllowedHeaders   []string `yaml:"allowed_headers"`
        ExposedHeaders   []string `yaml:"exposed_headers"`
        AllowCredentials bool     `yaml:"allow_credentials"`
        MaxAge           int      `yaml:"max_age"`
}

// MetricsConfig contains metrics configuration
type MetricsConfig struct {
        Enabled       bool   `yaml:"enabled"`
        Endpoint      string `yaml:"endpoint"`
        IncludeSystem bool   `yaml:"include_system"`
}

// TracingConfig contains tracing configuration
type TracingConfig struct {
        Enabled     bool    `yaml:"enabled"`
        Provider    string  `yaml:"provider"`
        Endpoint    string  `yaml:"endpoint"`
        ServiceName string  `yaml:"service_name"`
        SampleRate  float64 `yaml:"sample_rate"`
}

// RateLimitConfig represents rate limiting configuration
type RateLimitConfig struct {
        Requests int    `yaml:"requests"`
        Period   string `yaml:"period"`
}

// CacheSettings represents cache settings for a route
type CacheSettings struct {
        Enabled            bool `yaml:"enabled"`
        TTL                int  `yaml:"ttl"`
        CacheAuthenticated bool `yaml:"cache_authenticated"`
}

// CircuitBreakerSettings represents circuit breaker settings for a route
type CircuitBreakerSettings struct {
        Enabled       bool `yaml:"enabled"`
        Threshold     int  `yaml:"threshold"`
        Timeout       int  `yaml:"timeout"`
        MaxConcurrent int  `yaml:"max_concurrent"`
}

// WebSocketConfig represents websocket-specific configuration
type WebSocketConfig struct {
        Enabled      bool   `yaml:"enabled"`
        Path         string `yaml:"path"`
        UpstreamPath string `yaml:"upstream_path"`
}

// LoadConfig loads configuration from a YAML file
func LoadConfig(path string) (*Config, error) <span class="cov0" title="0">{
        configFile, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open config file: %w", err)
        }</span>
        <span class="cov0" title="0">defer configFile.Close()

        data, err := io.ReadAll(configFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read config file: %w", err)
        }</span>

        // Replace environment variables in the format ${VAR_NAME}
        <span class="cov0" title="0">data = replaceEnvVars(data)

        var config Config
        if err := yaml.Unmarshal(data, &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse config file: %w", err)
        }</span>

        // Set defaults
        <span class="cov0" title="0">setConfigDefaults(&amp;config)

        return &amp;config, nil</span>
}

// setConfigDefaults sets default values for the configuration
func setConfigDefaults(config *Config) <span class="cov0" title="0">{
        // Server defaults
        if config.Server.ReadTimeout == 0 </span><span class="cov0" title="0">{
                config.Server.ReadTimeout = 30 // Default read timeout of 30 seconds
        }</span>
        <span class="cov0" title="0">if config.Server.WriteTimeout == 0 </span><span class="cov0" title="0">{
                config.Server.WriteTimeout = 30 // Default write timeout of 30 seconds
        }</span>
        <span class="cov0" title="0">if config.Server.IdleTimeout == 0 </span><span class="cov0" title="0">{
                config.Server.IdleTimeout = 120 // Default idle timeout of 120 seconds
        }</span>
        <span class="cov0" title="0">if config.Server.MaxHeaderBytes == 0 </span><span class="cov0" title="0">{
                config.Server.MaxHeaderBytes = 1 &lt;&lt; 20 // Default max header bytes (1MB)
        }</span>

        // Auth defaults
        <span class="cov0" title="0">if config.Auth.JWTHeader == "" </span><span class="cov0" title="0">{
                config.Auth.JWTHeader = "Authorization"
        }</span>
        <span class="cov0" title="0">if config.Auth.APIKeyHeader == "" </span><span class="cov0" title="0">{
                config.Auth.APIKeyHeader = "X-API-Auth-Token"
        }</span>

        // Cache defaults
        <span class="cov0" title="0">if config.Cache.DefaultTTL == 0 </span><span class="cov0" title="0">{
                config.Cache.DefaultTTL = 60 // Default TTL of 60 seconds
        }</span>
        <span class="cov0" title="0">if config.Cache.MaxTTL == 0 </span><span class="cov0" title="0">{
                config.Cache.MaxTTL = 3600 // Default max TTL of 1 hour
        }</span>
        <span class="cov0" title="0">if config.Cache.MaxSize == 0 </span><span class="cov0" title="0">{
                config.Cache.MaxSize = 1000 // Default max size of 1000 entries
        }</span>
        <span class="cov0" title="0">if len(config.Cache.VaryHeaders) == 0 </span><span class="cov0" title="0">{
                config.Cache.VaryHeaders = []string{"Accept", "Accept-Encoding"}
        }</span>

        // CORS defaults
        <span class="cov0" title="0">if len(config.Cors.AllowedMethods) == 0 </span><span class="cov0" title="0">{
                config.Cors.AllowedMethods = []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"}
        }</span>
        <span class="cov0" title="0">if len(config.Cors.AllowedHeaders) == 0 </span><span class="cov0" title="0">{
                config.Cors.AllowedHeaders = []string{
                        "Origin", "Content-Type", "Accept", "Authorization",
                        "X-Requested-With", "X-API-Auth-Token",
                }
        }</span>
        <span class="cov0" title="0">if config.Cors.MaxAge == 0 </span><span class="cov0" title="0">{
                config.Cors.MaxAge = 86400 // Default max age of 24 hours
        }</span>

        // Security defaults
        <span class="cov0" title="0">if config.Security.HSTSMaxAge == 0 </span><span class="cov0" title="0">{
                config.Security.HSTSMaxAge = 31536000 // Default HSTS max age of 1 year
        }</span>
        <span class="cov0" title="0">if config.Security.MaxBodySize == 0 </span><span class="cov0" title="0">{
                config.Security.MaxBodySize = 10 &lt;&lt; 20 // Default max body size of 10MB
        }</span>

        // Metrics defaults
        <span class="cov0" title="0">if config.Metrics.Endpoint == "" </span><span class="cov0" title="0">{
                config.Metrics.Endpoint = "/metrics"
        }</span>

        // Tracing defaults
        <span class="cov0" title="0">if config.Tracing.Provider == "" </span><span class="cov0" title="0">{
                config.Tracing.Provider = "jaeger"
        }</span>
        <span class="cov0" title="0">if config.Tracing.ServiceName == "" </span><span class="cov0" title="0">{
                config.Tracing.ServiceName = "api-gateway"
        }</span>
        <span class="cov0" title="0">if config.Tracing.SampleRate == 0 </span><span class="cov0" title="0">{
                config.Tracing.SampleRate = 0.1 // Default sample rate of 10%
        }</span>
}

// replaceEnvVars replaces environment variables in the format ${VAR_NAME} with their values
func replaceEnvVars(data []byte) []byte <span class="cov0" title="0">{
        content := string(data)
        for _, env := range os.Environ() </span><span class="cov0" title="0">{
                pair := strings.SplitN(env, "=", 2)
                if len(pair) != 2 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">varName, varValue := pair[0], pair[1]
                placeholder := fmt.Sprintf("${%s}", varName)
                content = strings.ReplaceAll(content, placeholder, varValue)</span>
        }
        <span class="cov0" title="0">return []byte(content)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package config

import (
        "fmt"
        "os"

        "gopkg.in/yaml.v3"
)

// RouteConfig represents a route configuration in routes.yaml
type RouteConfig struct {
        Routes []Route `yaml:"routes"`
}

// Route represents a single API route
type Route struct {
        Path            string                  `yaml:"path"`
        Methods         []string                `yaml:"methods"`
        Upstream        string                  `yaml:"upstream"`
        StripPrefix     bool                    `yaml:"strip_prefix"`
        RequireAuth     bool                    `yaml:"require_auth"`
        Timeout         int                     `yaml:"timeout"`
        WebSocket       *WebSocketConfig        `yaml:"websocket"`
        RateLimit       *RateLimitConfig        `yaml:"rate_limit"`
        Cache           *RouteCacheConfig       `yaml:"cache"`
        CircuitBreaker  *CircuitBreakerSettings `yaml:"circuit_breaker"`
        RetryPolicy     *RetryPolicy            `yaml:"retry_policy"`
        LoadBalancing   *LoadBalancingConfig    `yaml:"load_balancing"`
        HeaderTransform *HeaderTransform        `yaml:"header_transform"`
        URLRewrite      *URLRewrite             `yaml:"url_rewrite"`
        ErrorHandling   *ErrorHandling          `yaml:"error_handling"`
        Compression     bool                    `yaml:"compression"`
        IPWhitelist     []string                `yaml:"ip_whitelist"`
        IPBlacklist     []string                `yaml:"ip_blacklist"`
}

// RouteCacheConfig contains cache configuration for a route
type RouteCacheConfig struct {
        Enabled            bool `yaml:"enabled"`
        TTL                int  `yaml:"ttl"`
        CacheAuthenticated bool `yaml:"cache_authenticated"`
}

// RetryPolicy represents retry configuration for a route
type RetryPolicy struct {
        Enabled       bool     `yaml:"enabled"`
        Attempts      int      `yaml:"attempts"`
        PerTryTimeout int      `yaml:"per_try_timeout"`
        RetryOn       []string `yaml:"retry_on"`
}

// LoadBalancingConfig represents load balancing configuration for a route
type LoadBalancingConfig struct {
        Method      string   `yaml:"method"`
        HealthCheck bool     `yaml:"health_check"`
        Endpoints   []string `yaml:"endpoints"`
}

// HeaderTransform represents header transformation configuration
type HeaderTransform struct {
        Request  map[string]string `yaml:"request"`
        Response map[string]string `yaml:"response"`
        Remove   []string          `yaml:"remove"`
}

// URLRewrite represents URL rewriting configuration
type URLRewrite struct {
        Patterns []URLRewritePattern `yaml:"patterns"`
}

// URLRewritePattern represents a URL rewrite pattern
type URLRewritePattern struct {
        Match       string `yaml:"match"`
        Replacement string `yaml:"replacement"`
}

// ErrorHandling represents error handling configuration
type ErrorHandling struct {
        DefaultMessage string         `yaml:"default_message"`
        StatusCodes    map[int]string `yaml:"status_codes"`
        Templates      map[int]string `yaml:"templates"`
}

// LoadRoutes loads route configurations from a YAML file
func LoadRoutes(path string) (*RouteConfig, error) <span class="cov0" title="0">{
        routesFile, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open routes file: %w", err)
        }</span>
        <span class="cov0" title="0">defer routesFile.Close()

        var routeConfig RouteConfig
        decoder := yaml.NewDecoder(routesFile)
        if err := decoder.Decode(&amp;routeConfig); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse routes file: %w", err)
        }</span>

        // Validate routes
        <span class="cov0" title="0">for i, route := range routeConfig.Routes </span><span class="cov0" title="0">{
                if route.Path == "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("route at index %d is missing 'path'", i)
                }</span>
                <span class="cov0" title="0">if route.Upstream == "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("route at index %d is missing 'upstream'", i)
                }</span>
                <span class="cov0" title="0">if len(route.Methods) == 0 </span><span class="cov0" title="0">{
                        // Default to all methods if none specified
                        routeConfig.Routes[i].Methods = []string{"GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS", "HEAD"}
                }</span>
                <span class="cov0" title="0">if route.Timeout == 0 </span><span class="cov0" title="0">{
                        // Default timeout of 30 seconds
                        routeConfig.Routes[i].Timeout = 30
                }</span>

                // Set defaults for retry policy
                <span class="cov0" title="0">if route.RetryPolicy != nil &amp;&amp; route.RetryPolicy.Enabled </span><span class="cov0" title="0">{
                        if route.RetryPolicy.Attempts == 0 </span><span class="cov0" title="0">{
                                routeConfig.Routes[i].RetryPolicy.Attempts = 3
                        }</span>
                        <span class="cov0" title="0">if route.RetryPolicy.PerTryTimeout == 0 </span><span class="cov0" title="0">{
                                routeConfig.Routes[i].RetryPolicy.PerTryTimeout = 5
                        }</span>
                }

                // Set defaults for circuit breaker
                <span class="cov0" title="0">if route.CircuitBreaker != nil &amp;&amp; route.CircuitBreaker.Enabled </span><span class="cov0" title="0">{
                        if route.CircuitBreaker.Threshold == 0 </span><span class="cov0" title="0">{
                                routeConfig.Routes[i].CircuitBreaker.Threshold = 5
                        }</span>
                        <span class="cov0" title="0">if route.CircuitBreaker.Timeout == 0 </span><span class="cov0" title="0">{
                                routeConfig.Routes[i].CircuitBreaker.Timeout = 30
                        }</span>
                }

                // Set defaults for cache
                <span class="cov0" title="0">if route.Cache != nil &amp;&amp; route.Cache.Enabled </span><span class="cov0" title="0">{
                        if route.Cache.TTL == 0 </span><span class="cov0" title="0">{
                                routeConfig.Routes[i].Cache.TTL = 60
                        }</span>
                }
        }

        <span class="cov0" title="0">return &amp;routeConfig, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package handlers

import (
        "encoding/json"
        "net/http"
        "time"
)

// HealthResponse represents the health check response
type HealthResponse struct {
        Status    string    `json:"status"`
        Timestamp time.Time `json:"timestamp"`
        Version   string    `json:"version"`
}

// ErrorResponse represents an error response
type ErrorResponse struct {
        Error   string `json:"error"`
        Code    int    `json:"code"`
        Message string `json:"message,omitempty"`
}

// HealthCheckHandler handles health check requests
func HealthCheckHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        resp := HealthResponse{
                Status:    "ok",
                Timestamp: time.Now(),
                Version:   "1.0.0", // This could be loaded from a version file or build info
        }

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(resp)
}</span>

// NotFoundHandler handles 404 not found requests
func NotFoundHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        resp := ErrorResponse{
                Error:   "not_found",
                Code:    http.StatusNotFound,
                Message: "The requested resource was not found",
        }

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusNotFound)
        json.NewEncoder(w).Encode(resp)
}</span>

// MethodNotAllowedHandler handles 405 method not allowed requests
func MethodNotAllowedHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        resp := ErrorResponse{
                Error:   "method_not_allowed",
                Code:    http.StatusMethodNotAllowed,
                Message: "The requested method is not allowed for this resource",
        }

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusMethodNotAllowed)
        json.NewEncoder(w).Encode(resp)
}</span>

// InternalErrorHandler handles 500 internal server error responses
func InternalErrorHandler(w http.ResponseWriter, r *http.Request, err error) <span class="cov0" title="0">{
        resp := ErrorResponse{
                Error:   "internal_server_error",
                Code:    http.StatusInternalServerError,
                Message: "An internal server error occurred",
        }

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusInternalServerError)
        json.NewEncoder(w).Encode(resp)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package middleware

import (
        "net/http"

        "api-gateway/internal/auth"
        "api-gateway/internal/config"
        "api-gateway/pkg/logger"
)

// AuthMiddleware provides authentication middleware functionality
type AuthMiddleware struct {
        authService *auth.AuthService
        authConfig  *config.AuthConfig
        log         logger.Logger
}

// NewAuthMiddleware creates a new authentication middleware
func NewAuthMiddleware(authService *auth.AuthService, authConfig *config.AuthConfig, log logger.Logger) *AuthMiddleware <span class="cov0" title="0">{
        return &amp;AuthMiddleware{
                authService: authService,
                authConfig:  authConfig,
                log:         log,
        }
}</span>

// Authenticate checks if the request has valid authentication
func (m *AuthMiddleware) Authenticate(next http.Handler, route config.Route) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Skip authentication if not required for this route
                if !route.RequireAuth </span><span class="cov0" title="0">{
                        next.ServeHTTP(w, r)
                        return
                }</span>

                // Extract the API key from headers if present
                <span class="cov0" title="0">apiKey := r.Header.Get("x-api-key")
                if apiKey != "" </span><span class="cov0" title="0">{
                        // If API key is present, set it to the expected header name
                        r.Header.Set(m.authConfig.APIKeyHeader, apiKey)
                }</span>

                // Validate the token - passing empty slice for allowedRoles to skip role checking
                <span class="cov0" title="0">valid, err := m.authService.ValidateToken(r, []string{})
                if err != nil </span><span class="cov0" title="0">{
                        m.log.Debug("Authentication failed",
                                logger.String("path", r.URL.Path),
                                logger.String("method", r.Method),
                                logger.Error(err),
                        )

                        // Send appropriate error response
                        switch err </span>{
                        case auth.ErrNoToken:<span class="cov0" title="0">
                                http.Error(w, "Authorization required", http.StatusUnauthorized)</span>
                        case auth.ErrInvalidToken, auth.ErrExpiredToken:<span class="cov0" title="0">
                                http.Error(w, err.Error(), http.StatusUnauthorized)</span>
                        case auth.ErrForbidden:<span class="cov0" title="0">
                                http.Error(w, "Forbidden: Insufficient permissions", http.StatusForbidden)</span>
                        default:<span class="cov0" title="0">
                                http.Error(w, "Authentication failed", http.StatusUnauthorized)</span>
                        }
                        <span class="cov0" title="0">return</span>
                }

                <span class="cov0" title="0">if !valid </span><span class="cov0" title="0">{
                        m.log.Debug("Authentication invalid",
                                logger.String("path", r.URL.Path),
                                logger.String("method", r.Method),
                        )
                        http.Error(w, "Authentication failed", http.StatusUnauthorized)
                        return
                }</span>

                // Authentication succeeded, continue to the next handler
                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package middleware

import (
        "bytes"
        "crypto/sha256"
        "encoding/hex"
        "net/http"
        "strconv"
        "strings"
        "sync"
        "time"

        "api-gateway/internal/config"
        "api-gateway/pkg/logger"
)

// CacheEntry represents a cached HTTP response
type CacheEntry struct {
        StatusCode int
        Body       []byte
        Headers    http.Header
        Expiration time.Time
}

// CacheMiddleware provides HTTP response caching
type CacheMiddleware struct {
        cache  map[string]*CacheEntry
        mutex  sync.RWMutex
        config *config.CacheConfig
        log    logger.Logger
}

// NewCacheMiddleware creates a new cache middleware
func NewCacheMiddleware(config *config.CacheConfig, log logger.Logger) *CacheMiddleware <span class="cov0" title="0">{
        return &amp;CacheMiddleware{
                cache:  make(map[string]*CacheEntry),
                config: config,
                log:    log,
        }
}</span>

// Cache middleware caches responses for GET requests
func (c *CacheMiddleware) Cache(next http.Handler, route config.Route) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Skip caching if not enabled for this route or if it's not a GET request
                if !c.shouldCache(r, route) </span><span class="cov0" title="0">{
                        next.ServeHTTP(w, r)
                        return
                }</span>

                // Generate cache key from request
                <span class="cov0" title="0">key := c.generateCacheKey(r)

                // Try to get from cache
                entry := c.getFromCache(key)
                if entry != nil </span><span class="cov0" title="0">{
                        c.log.Debug("Cache hit",
                                logger.String("path", r.URL.Path),
                                logger.String("method", r.Method),
                                logger.String("key", key),
                        )
                        c.serveFromCache(w, entry)
                        return
                }</span>

                // If not in cache, capture the response
                <span class="cov0" title="0">c.log.Debug("Cache miss",
                        logger.String("path", r.URL.Path),
                        logger.String("method", r.Method),
                        logger.String("key", key),
                )

                // Create a buffer to store the response
                buf := &amp;bytes.Buffer{}

                // Create a custom response writer to capture the response
                crw := &amp;cachingResponseWriter{
                        ResponseWriter: w,
                        buffer:         buf,
                        statusCode:     http.StatusOK,
                        headers:        make(http.Header),
                }

                // Process the request
                next.ServeHTTP(crw, r)

                // Don't cache error responses
                if crw.statusCode &gt;= 400 </span><span class="cov0" title="0">{
                        return
                }</span>

                // Determine TTL for cache entry
                <span class="cov0" title="0">ttl := c.getTTL(r, crw.headers, route)
                if ttl &lt;= 0 </span><span class="cov0" title="0">{
                        return
                }</span>

                // Store in cache
                <span class="cov0" title="0">c.storeInCache(key, crw.statusCode, buf.Bytes(), crw.headers, ttl)</span>
        })
}

// shouldCache determines if a request should be cached
func (c *CacheMiddleware) shouldCache(r *http.Request, route config.Route) bool <span class="cov0" title="0">{
        // Check if cache is globally disabled
        if !c.config.Enabled </span><span class="cov0" title="0">{
                return false
        }</span>

        // Only cache enabled routes
        <span class="cov0" title="0">if route.Cache == nil || !route.Cache.Enabled </span><span class="cov0" title="0">{
                return false
        }</span>

        // Only cache GET requests
        <span class="cov0" title="0">if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                return false
        }</span>

        // Don't cache if Cache-Control: no-cache or no-store
        <span class="cov0" title="0">cacheControl := r.Header.Get("Cache-Control")
        if strings.Contains(cacheControl, "no-cache") || strings.Contains(cacheControl, "no-store") </span><span class="cov0" title="0">{
                return false
        }</span>

        // Don't cache authenticated requests unless specified
        <span class="cov0" title="0">if !route.Cache.CacheAuthenticated &amp;&amp; (r.Header.Get("Authorization") != "" || r.Header.Get("x-api-key") != "") </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

// generateCacheKey creates a unique key for the cache entry
func (c *CacheMiddleware) generateCacheKey(r *http.Request) string <span class="cov0" title="0">{
        // Basic key components
        key := r.Method + ":" + r.URL.Path + ":" + r.URL.RawQuery

        // Add host if vhost-based routing is used
        if c.config.IncludeHost </span><span class="cov0" title="0">{
                key = r.Host + ":" + key
        }</span>

        // Add certain headers to the key if configured
        <span class="cov0" title="0">for _, header := range c.config.VaryHeaders </span><span class="cov0" title="0">{
                if value := r.Header.Get(header); value != "" </span><span class="cov0" title="0">{
                        key += ":" + header + "=" + value
                }</span>
        }

        // Hash the key to keep it a reasonable length
        <span class="cov0" title="0">hasher := sha256.New()
        hasher.Write([]byte(key))
        return hex.EncodeToString(hasher.Sum(nil))</span>
}

// getFromCache retrieves a value from the cache
func (c *CacheMiddleware) getFromCache(key string) *CacheEntry <span class="cov0" title="0">{
        c.mutex.RLock()
        defer c.mutex.RUnlock()

        entry, exists := c.cache[key]
        if !exists </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Check if entry has expired
        <span class="cov0" title="0">if time.Now().After(entry.Expiration) </span><span class="cov0" title="0">{
                // Expired entry, remove it
                go c.removeFromCache(key)
                return nil
        }</span>

        <span class="cov0" title="0">return entry</span>
}

// removeFromCache removes a value from the cache
func (c *CacheMiddleware) removeFromCache(key string) <span class="cov0" title="0">{
        c.mutex.Lock()
        defer c.mutex.Unlock()

        delete(c.cache, key)
}</span>

// storeInCache stores a value in the cache
func (c *CacheMiddleware) storeInCache(key string, statusCode int, body []byte, headers http.Header, ttl time.Duration) <span class="cov0" title="0">{
        c.mutex.Lock()
        defer c.mutex.Unlock()

        // Create a copy of the headers
        headersCopy := make(http.Header)
        for k, v := range headers </span><span class="cov0" title="0">{
                headersCopy[k] = v
        }</span>

        // Create a cache entry
        <span class="cov0" title="0">entry := &amp;CacheEntry{
                StatusCode: statusCode,
                Body:       body,
                Headers:    headersCopy,
                Expiration: time.Now().Add(ttl),
        }

        // Store in cache
        c.cache[key] = entry

        // Set up automatic expiration
        go func() </span><span class="cov0" title="0">{
                time.Sleep(ttl)
                c.removeFromCache(key)
        }</span>()
}

// serveFromCache serves a cached response
func (c *CacheMiddleware) serveFromCache(w http.ResponseWriter, entry *CacheEntry) <span class="cov0" title="0">{
        // Copy headers from cached response
        for k, v := range entry.Headers </span><span class="cov0" title="0">{
                for _, val := range v </span><span class="cov0" title="0">{
                        w.Header().Add(k, val)
                }</span>
        }

        // Add cache header to indicate this was a cached response
        <span class="cov0" title="0">w.Header().Set("X-Cache", "HIT")

        // Set status code and write body
        w.WriteHeader(entry.StatusCode)
        w.Write(entry.Body)</span>
}

// getTTL determines the TTL for a cache entry
func (c *CacheMiddleware) getTTL(r *http.Request, headers http.Header, route config.Route) time.Duration <span class="cov0" title="0">{
        // Default TTL from route config
        ttl := time.Duration(route.Cache.TTL) * time.Second

        // Check for Cache-Control: max-age
        cacheControl := headers.Get("Cache-Control")
        if strings.Contains(cacheControl, "max-age=") </span><span class="cov0" title="0">{
                parts := strings.Split(cacheControl, "max-age=")
                if len(parts) &gt; 1 </span><span class="cov0" title="0">{
                        maxAge := strings.Split(parts[1], ",")[0]
                        if seconds, err := strconv.Atoi(maxAge); err == nil </span><span class="cov0" title="0">{
                                return time.Duration(seconds) * time.Second
                        }</span>
                }
        }

        // Check for Expires header
        <span class="cov0" title="0">expires := headers.Get("Expires")
        if expires != "" </span><span class="cov0" title="0">{
                if expTime, err := time.Parse(time.RFC1123, expires); err == nil </span><span class="cov0" title="0">{
                        ttl = expTime.Sub(time.Now())
                }</span>
        }

        // If TTL is negative or zero, don't cache
        <span class="cov0" title="0">if ttl &lt;= 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        // Apply maximum TTL if configured
        <span class="cov0" title="0">if c.config.MaxTTL &gt; 0 &amp;&amp; ttl &gt; time.Duration(c.config.MaxTTL)*time.Second </span><span class="cov0" title="0">{
                ttl = time.Duration(c.config.MaxTTL) * time.Second
        }</span>

        <span class="cov0" title="0">return ttl</span>
}

// cachingResponseWriter captures the response for caching
type cachingResponseWriter struct {
        http.ResponseWriter
        buffer     *bytes.Buffer
        statusCode int
        headers    http.Header
}

// WriteHeader captures the status code
func (crw *cachingResponseWriter) WriteHeader(statusCode int) <span class="cov0" title="0">{
        crw.statusCode = statusCode
        crw.ResponseWriter.WriteHeader(statusCode)
}</span>

// Write captures the response body
func (crw *cachingResponseWriter) Write(b []byte) (int, error) <span class="cov0" title="0">{
        crw.buffer.Write(b)
        return crw.ResponseWriter.Write(b)
}</span>

// Header captures the response headers
func (crw *cachingResponseWriter) Header() http.Header <span class="cov0" title="0">{
        h := crw.ResponseWriter.Header()

        // Copy headers to our internal storage
        for k, v := range h </span><span class="cov0" title="0">{
                crw.headers[k] = v
        }</span>

        <span class="cov0" title="0">return h</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package middleware

import (
        "net/http"
        "strconv"
        "strings"

        "api-gateway/internal/config"
        "api-gateway/pkg/logger"
)

// CORSMiddleware provides CORS functionality
type CORSMiddleware struct {
        config *config.CORSConfig
        log    logger.Logger
}

// NewCORSMiddleware creates a new CORS middleware
func NewCORSMiddleware(config *config.CORSConfig, log logger.Logger) *CORSMiddleware <span class="cov0" title="0">{
        return &amp;CORSMiddleware{
                config: config,
                log:    log,
        }
}</span>

// CORS middleware handles Cross-Origin Resource Sharing
func (c *CORSMiddleware) CORS(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // If CORS is disabled, just pass through
                if !c.config.Enabled </span><span class="cov0" title="0">{
                        next.ServeHTTP(w, r)
                        return
                }</span>

                <span class="cov0" title="0">origin := r.Header.Get("Origin")
                if origin == "" </span><span class="cov0" title="0">{
                        // Not a CORS request, continue
                        next.ServeHTTP(w, r)
                        return
                }</span>

                // Check if the origin is allowed
                <span class="cov0" title="0">if !c.isOriginAllowed(origin) </span><span class="cov0" title="0">{
                        // Origin not allowed, continue without CORS headers
                        next.ServeHTTP(w, r)
                        return
                }</span>

                // Set allowed origin
                <span class="cov0" title="0">useWildcard := c.config.AllowAllOrigins ||
                        (len(c.config.AllowedOrigins) == 1 &amp;&amp; c.config.AllowedOrigins[0] == "*" &amp;&amp;
                                !c.config.AllowCredentials)

                if useWildcard </span><span class="cov0" title="0">{
                        w.Header().Set("Access-Control-Allow-Origin", "*")
                }</span> else<span class="cov0" title="0"> {
                        w.Header().Set("Access-Control-Allow-Origin", origin)
                        w.Header().Set("Vary", "Origin")
                }</span>

                // Set other CORS headers
                <span class="cov0" title="0">if c.config.AllowCredentials </span><span class="cov0" title="0">{
                        w.Header().Set("Access-Control-Allow-Credentials", "true")
                }</span>

                <span class="cov0" title="0">if len(c.config.ExposedHeaders) &gt; 0 </span><span class="cov0" title="0">{
                        w.Header().Set("Access-Control-Expose-Headers", strings.Join(c.config.ExposedHeaders, ","))
                }</span>

                // Handle preflight requests
                <span class="cov0" title="0">if r.Method == http.MethodOptions </span><span class="cov0" title="0">{
                        requestMethod := r.Header.Get("Access-Control-Request-Method")
                        if requestMethod != "" </span><span class="cov0" title="0">{
                                // Set preflight headers
                                w.Header().Set("Access-Control-Allow-Methods", strings.Join(c.config.AllowedMethods, ","))
                                w.Header().Set("Access-Control-Allow-Headers", strings.Join(c.config.AllowedHeaders, ","))
                                w.Header().Set("Access-Control-Max-Age", strconv.Itoa(c.config.MaxAge))

                                c.log.Info("CORS preflight request processed",
                                        logger.String("origin", origin),
                                        logger.String("method", requestMethod),
                                )

                                // Preflight request completed, no need to call the next handler
                                w.WriteHeader(http.StatusOK)
                                return
                        }</span>
                }

                // Continue with the request
                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}

// isOriginAllowed checks if the origin is allowed
func (c *CORSMiddleware) isOriginAllowed(origin string) bool <span class="cov0" title="0">{
        if c.config.AllowAllOrigins </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">for _, allowedOrigin := range c.config.AllowedOrigins </span><span class="cov0" title="0">{
                if allowedOrigin == "*" </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">if allowedOrigin == origin </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package middleware

import (
        "net/http"

        "api-gateway/internal/config"
        "api-gateway/pkg/logger"
)

// HeaderTransformer handles transformation of HTTP headers
type HeaderTransformer struct {
        log logger.Logger
}

// NewHeaderTransformer creates a new header transformation middleware
func NewHeaderTransformer(log logger.Logger) *HeaderTransformer <span class="cov0" title="0">{
        return &amp;HeaderTransformer{
                log: log,
        }
}</span>

// Transform applies header transformations based on configuration
func (h *HeaderTransformer) Transform(next http.Handler, transform *config.HeaderTransform) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if transform == nil </span><span class="cov0" title="0">{
                        next.ServeHTTP(w, r)
                        return
                }</span>

                // Apply request header transformations
                <span class="cov0" title="0">for key, value := range transform.Request </span><span class="cov0" title="0">{
                        r.Header.Set(key, value)
                }</span>

                // Create a custom response writer to handle response header transformations
                <span class="cov0" title="0">tw := &amp;transformResponseWriter{
                        ResponseWriter: w,
                        transform:      transform,
                        log:            h.log,
                }

                // Continue to next handler with our custom response writer
                next.ServeHTTP(tw, r)</span>
        })
}

// transformResponseWriter is a wrapper for http.ResponseWriter that
// applies header transformations to responses
type transformResponseWriter struct {
        http.ResponseWriter
        transform   *config.HeaderTransform
        log         logger.Logger
        wroteHeader bool
}

// WriteHeader overrides the original WriteHeader to apply header transformations
func (tw *transformResponseWriter) WriteHeader(statusCode int) <span class="cov0" title="0">{
        if tw.wroteHeader </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">tw.wroteHeader = true

        // Apply response header transformations
        for key, value := range tw.transform.Response </span><span class="cov0" title="0">{
                // Empty value means remove the header
                if value == "" </span><span class="cov0" title="0">{
                        tw.ResponseWriter.Header().Del(key)
                }</span> else<span class="cov0" title="0"> {
                        tw.ResponseWriter.Header().Set(key, value)
                }</span>
        }

        // Remove headers if specified
        <span class="cov0" title="0">for _, header := range tw.transform.Remove </span><span class="cov0" title="0">{
                tw.ResponseWriter.Header().Del(header)
        }</span>

        <span class="cov0" title="0">tw.ResponseWriter.WriteHeader(statusCode)</span>
}

// Write overrides the original Write method to ensure headers are written
func (tw *transformResponseWriter) Write(b []byte) (int, error) <span class="cov0" title="0">{
        if !tw.wroteHeader </span><span class="cov0" title="0">{
                tw.WriteHeader(http.StatusOK)
        }</span>
        <span class="cov0" title="0">return tw.ResponseWriter.Write(b)</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package middleware

import (
        "net/http"
        "strconv"
        "time"

        "api-gateway/internal/config"
        "api-gateway/pkg/logger"

        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promhttp"
)

var (
        // RequestDuration tracks request duration
        requestDuration = prometheus.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "gateway_request_duration_seconds",
                        Help:    "Request duration in seconds",
                        Buckets: prometheus.DefBuckets,
                },
                []string{"method", "path", "status"},
        )

        // RequestsTotal tracks the total number of requests
        requestsTotal = prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "gateway_requests_total",
                        Help: "Total number of requests",
                },
                []string{"method", "path", "status"},
        )

        // CircuitBreakerStatus tracks circuit breaker status
        circuitBreakerStatus = prometheus.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "gateway_circuit_breaker_status",
                        Help: "Circuit breaker status (0=closed, 1=open, 2=half-open)",
                },
                []string{"path"},
        )

        // CacheHits tracks cache hits
        cacheHits = prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "gateway_cache_hits_total",
                        Help: "Total number of cache hits",
                },
                []string{"path"},
        )

        // CacheMisses tracks cache misses
        cacheMisses = prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "gateway_cache_misses_total",
                        Help: "Total number of cache misses",
                },
                []string{"path"},
        )

        // RateLimitRejections tracks rate limit rejections
        rateLimitRejections = prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "gateway_rate_limit_rejections_total",
                        Help: "Total number of requests rejected due to rate limits",
                },
                []string{"path"},
        )
)

func init() <span class="cov0" title="0">{
        // Register metrics with Prometheus
        prometheus.MustRegister(requestDuration)
        prometheus.MustRegister(requestsTotal)
        prometheus.MustRegister(circuitBreakerStatus)
        prometheus.MustRegister(cacheHits)
        prometheus.MustRegister(cacheMisses)
        prometheus.MustRegister(rateLimitRejections)
}</span>

// MetricsMiddleware provides metrics collection and endpoints
type MetricsMiddleware struct {
        config *config.MetricsConfig
        log    logger.Logger
}

// NewMetricsMiddleware creates a new metrics middleware
func NewMetricsMiddleware(config *config.MetricsConfig, log logger.Logger) *MetricsMiddleware <span class="cov0" title="0">{
        return &amp;MetricsMiddleware{
                config: config,
                log:    log,
        }
}</span>

// RegisterMetricsEndpoint registers the metrics endpoint
func (m *MetricsMiddleware) RegisterMetricsEndpoint(router http.Handler) http.Handler <span class="cov0" title="0">{
        if !m.config.Enabled </span><span class="cov0" title="0">{
                return router
        }</span>

        // Create a handler for the metrics endpoint
        <span class="cov0" title="0">handler := http.NewServeMux()

        // Copy all requests to the original router
        handler.Handle("/", router)

        // Add the metrics endpoint
        handler.Handle(m.config.Endpoint, promhttp.Handler())

        m.log.Info("Registered metrics endpoint",
                logger.String("endpoint", m.config.Endpoint),
        )

        return handler</span>
}

// Metrics middleware collects metrics for each request
func (m *MetricsMiddleware) Metrics(next http.Handler) http.Handler <span class="cov0" title="0">{
        if !m.config.Enabled </span><span class="cov0" title="0">{
                return next
        }</span>

        <span class="cov0" title="0">return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                start := time.Now()

                // Create a response writer that captures the status code
                recorder := &amp;responseRecorder{
                        ResponseWriter: w,
                        statusCode:     http.StatusOK,
                }

                // Process the request
                next.ServeHTTP(recorder, r)

                // Record metrics
                duration := time.Since(start).Seconds()
                path := r.URL.Path
                method := r.Method
                status := strconv.Itoa(recorder.statusCode)

                requestDuration.WithLabelValues(method, path, status).Observe(duration)
                requestsTotal.WithLabelValues(method, path, status).Inc()
        }</span>)
}

// IncrementCacheHit increments the cache hit counter
func (m *MetricsMiddleware) IncrementCacheHit(path string) <span class="cov0" title="0">{
        if m.config.Enabled </span><span class="cov0" title="0">{
                cacheHits.WithLabelValues(path).Inc()
        }</span>
}

// IncrementCacheMiss increments the cache miss counter
func (m *MetricsMiddleware) IncrementCacheMiss(path string) <span class="cov0" title="0">{
        if m.config.Enabled </span><span class="cov0" title="0">{
                cacheMisses.WithLabelValues(path).Inc()
        }</span>
}

// IncrementRateLimit increments the rate limit counter
func (m *MetricsMiddleware) IncrementRateLimit(path string) <span class="cov0" title="0">{
        if m.config.Enabled </span><span class="cov0" title="0">{
                rateLimitRejections.WithLabelValues(path).Inc()
        }</span>
}

// SetCircuitBreakerStatus sets the circuit breaker status
func (m *MetricsMiddleware) SetCircuitBreakerStatus(path string, status float64) <span class="cov0" title="0">{
        if m.config.Enabled </span><span class="cov0" title="0">{
                circuitBreakerStatus.WithLabelValues(path).Set(status)
        }</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package middleware

import (
        "net/http"
        "sync"
        "time"

        "api-gateway/internal/config"
        "api-gateway/pkg/logger"
)

// RateLimiter represents a rate limiting middleware
type RateLimiter struct {
        limits       map[string]config.RateLimitConfig
        buckets      map[string]map[string]*tokenBucket
        bucketsMutex sync.RWMutex
        log          logger.Logger
}

// tokenBucket implements the token bucket algorithm for rate limiting
type tokenBucket struct {
        tokens         float64
        maxTokens      float64
        refillRate     float64
        lastRefillTime time.Time
        mutex          sync.Mutex
}

// NewRateLimiter creates a new rate limiting middleware
func NewRateLimiter(log logger.Logger) *RateLimiter <span class="cov0" title="0">{
        return &amp;RateLimiter{
                limits:  make(map[string]config.RateLimitConfig),
                buckets: make(map[string]map[string]*tokenBucket),
                log:     log,
        }
}</span>

// AddLimit adds a rate limit for a specific path
func (rl *RateLimiter) AddLimit(path string, limit config.RateLimitConfig) <span class="cov0" title="0">{
        rl.limits[path] = limit
        rl.buckets[path] = make(map[string]*tokenBucket)
}</span>

// getBucket gets or creates a token bucket for a client
func (rl *RateLimiter) getBucket(path, clientID string) *tokenBucket <span class="cov0" title="0">{
        rl.bucketsMutex.RLock()
        bucket, exists := rl.buckets[path][clientID]
        rl.bucketsMutex.RUnlock()

        if exists </span><span class="cov0" title="0">{
                return bucket
        }</span>

        // Create a new bucket if it doesn't exist
        <span class="cov0" title="0">rl.bucketsMutex.Lock()
        defer rl.bucketsMutex.Unlock()

        // Check again to avoid race conditions
        if bucket, exists = rl.buckets[path][clientID]; exists </span><span class="cov0" title="0">{
                return bucket
        }</span>

        <span class="cov0" title="0">limit, exists := rl.limits[path]
        if !exists </span><span class="cov0" title="0">{
                // If no specific limit is set for this path, create a default bucket
                // that doesn't actually rate limit (high limit)
                bucket = &amp;tokenBucket{
                        tokens:         1000,
                        maxTokens:      1000,
                        refillRate:     1000,
                        lastRefillTime: time.Now(),
                }
        }</span> else<span class="cov0" title="0"> {
                // Calculate tokens per second based on the limit
                var tokensPerSecond float64
                switch limit.Period </span>{
                case "second":<span class="cov0" title="0">
                        tokensPerSecond = float64(limit.Requests)</span>
                case "minute":<span class="cov0" title="0">
                        tokensPerSecond = float64(limit.Requests) / 60</span>
                case "hour":<span class="cov0" title="0">
                        tokensPerSecond = float64(limit.Requests) / 3600</span>
                case "day":<span class="cov0" title="0">
                        tokensPerSecond = float64(limit.Requests) / 86400</span>
                default:<span class="cov0" title="0">
                        tokensPerSecond = float64(limit.Requests) / 60</span> // Default to minute
                }

                <span class="cov0" title="0">bucket = &amp;tokenBucket{
                        tokens:         float64(limit.Requests),
                        maxTokens:      float64(limit.Requests),
                        refillRate:     tokensPerSecond,
                        lastRefillTime: time.Now(),
                }</span>
        }

        <span class="cov0" title="0">rl.buckets[path][clientID] = bucket
        return bucket</span>
}

// RateLimit middleware applies rate limiting to requests
func (rl *RateLimiter) RateLimit(next http.Handler, route config.Route) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Skip rate limiting if not configured for this route
                if route.RateLimit == nil || route.RateLimit.Requests == 0 </span><span class="cov0" title="0">{
                        next.ServeHTTP(w, r)
                        return
                }</span>

                // Use client IP as identifier for rate limiting
                // In production, you might want to use a more sophisticated method
                // like API keys or user IDs if available
                <span class="cov0" title="0">clientID := r.RemoteAddr

                // Get the bucket for this client
                bucket := rl.getBucket(route.Path, clientID)

                // Try to consume a token
                if allowed := rl.tryConsume(bucket); !allowed </span><span class="cov0" title="0">{
                        rl.log.Debug("Rate limit exceeded",
                                logger.String("path", r.URL.Path),
                                logger.String("method", r.Method),
                                logger.String("client", clientID),
                        )

                        w.Header().Set("Retry-After", "1") // Suggest retry after 1 second
                        http.Error(w, "Rate limit exceeded", http.StatusTooManyRequests)
                        return
                }</span>

                // Continue to the next handler
                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}

// tryConsume attempts to consume a token from the bucket
func (rl *RateLimiter) tryConsume(bucket *tokenBucket) bool <span class="cov0" title="0">{
        bucket.mutex.Lock()
        defer bucket.mutex.Unlock()

        now := time.Now()
        elapsed := now.Sub(bucket.lastRefillTime).Seconds()

        // Refill the bucket based on time elapsed
        bucket.tokens = bucket.tokens + (elapsed * bucket.refillRate)
        if bucket.tokens &gt; bucket.maxTokens </span><span class="cov0" title="0">{
                bucket.tokens = bucket.maxTokens
        }</span>

        <span class="cov0" title="0">bucket.lastRefillTime = now

        // Check if we can consume a token
        if bucket.tokens &lt; 1 </span><span class="cov0" title="0">{
                return false
        }</span>

        // Consume a token
        <span class="cov0" title="0">bucket.tokens--
        return true</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package middleware

import (
        "bytes"
        "context"
        "io"
        "net/http"
        "strings"
        "time"

        "api-gateway/internal/config"
        "api-gateway/pkg/logger"
)

// RetryMiddleware provides retry functionality for failed requests
type RetryMiddleware struct {
        log logger.Logger
}

// NewRetryMiddleware creates a new retry middleware
func NewRetryMiddleware(log logger.Logger) *RetryMiddleware <span class="cov0" title="0">{
        return &amp;RetryMiddleware{
                log: log,
        }
}</span>

// Retry wraps a handler with retry logic
func (r *RetryMiddleware) Retry(next http.Handler, policy *config.RetryPolicy) http.Handler <span class="cov0" title="0">{
        if policy == nil || !policy.Enabled || policy.Attempts &lt;= 1 </span><span class="cov0" title="0">{
                return next
        }</span>

        <span class="cov0" title="0">return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) </span><span class="cov0" title="0">{
                // Create a response recorder to capture the response
                recorder := &amp;responseRecorder{
                        ResponseWriter: w,
                        statusCode:     http.StatusOK,
                        body:           &amp;bytes.Buffer{},
                }

                var err error
                // Copy the request body for potential retries
                var bodyBytes []byte
                if req.Body != nil </span><span class="cov0" title="0">{
                        bodyBytes, err = io.ReadAll(req.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                r.log.Error("Failed to read request body",
                                        logger.String("path", req.URL.Path),
                                        logger.Error(err),
                                )
                                http.Error(w, "Internal Server Error", http.StatusInternalServerError)
                                return
                        }</span>
                        <span class="cov0" title="0">req.Body.Close()</span>
                }

                // Try the request multiple times if needed
                <span class="cov0" title="0">attempts := policy.Attempts
                perTryTimeout := time.Duration(policy.PerTryTimeout) * time.Second

                for attempt := 1; attempt &lt;= attempts; attempt++ </span><span class="cov0" title="0">{
                        // Reset the request body if needed
                        if bodyBytes != nil </span><span class="cov0" title="0">{
                                req.Body = io.NopCloser(bytes.NewReader(bodyBytes))
                        }</span>

                        // Track the attempt in request headers for debugging
                        <span class="cov0" title="0">req.Header.Set("X-Retry-Attempt",
                                strings.Join([]string{
                                        string('0' + rune(attempt)),
                                        string('0' + rune(attempts))},
                                        "/"))

                        // Create a context with timeout for this attempt
                        ctx := req.Context()
                        if perTryTimeout &gt; 0 </span><span class="cov0" title="0">{
                                var cancel context.CancelFunc
                                ctx, cancel = context.WithTimeout(req.Context(), perTryTimeout)
                                defer cancel()
                        }</span>

                        // Serve the request with the new context
                        <span class="cov0" title="0">recorder.Reset()
                        next.ServeHTTP(recorder, req.WithContext(ctx))

                        // Check if we should retry
                        shouldRetry := r.shouldRetry(policy.RetryOn, recorder.statusCode, err)
                        if !shouldRetry || attempt == attempts </span><span class="cov0" title="0">{
                                // On the last attempt or if we shouldn't retry, copy the response to the original writer
                                for key, values := range recorder.Header() </span><span class="cov0" title="0">{
                                        for _, value := range values </span><span class="cov0" title="0">{
                                                w.Header().Add(key, value)
                                        }</span>
                                }
                                <span class="cov0" title="0">w.WriteHeader(recorder.statusCode)
                                w.Write(recorder.body.Bytes())
                                return</span>
                        }

                        <span class="cov0" title="0">r.log.Debug("Retrying request",
                                logger.String("path", req.URL.Path),
                                logger.Int("attempt", attempt),
                                logger.Int("max_attempts", attempts),
                                logger.Int("status_code", recorder.statusCode),
                        )

                        // Slight delay before retry using exponential backoff
                        backoff := time.Duration(attempt*attempt*50) * time.Millisecond
                        time.Sleep(backoff)</span>
                }
        })
}

// shouldRetry determines if a request should be retried based on the retry policy
func (r *RetryMiddleware) shouldRetry(retryOn []string, statusCode int, err error) bool <span class="cov0" title="0">{
        // If there was a network error, retry
        if err != nil </span><span class="cov0" title="0">{
                return contains(retryOn, "connection_error") || contains(retryOn, "network_error")
        }</span>

        // Check status code based retry conditions
        <span class="cov0" title="0">if statusCode &gt;= 500 &amp;&amp; contains(retryOn, "server_error") </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">if statusCode == http.StatusTooManyRequests &amp;&amp; contains(retryOn, "rate_limited") </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">if statusCode == http.StatusGatewayTimeout &amp;&amp; contains(retryOn, "gateway_timeout") </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// contains checks if a string slice contains a specific value
func contains(slice []string, item string) bool <span class="cov0" title="0">{
        for _, s := range slice </span><span class="cov0" title="0">{
                if s == item </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// responseRecorder is a wrapper around http.ResponseWriter that records the response
type responseRecorder struct {
        http.ResponseWriter
        statusCode int
        body       *bytes.Buffer
}

// WriteHeader captures the status code
func (r *responseRecorder) WriteHeader(statusCode int) <span class="cov0" title="0">{
        r.statusCode = statusCode
}</span>

// Write captures the response body
func (r *responseRecorder) Write(b []byte) (int, error) <span class="cov0" title="0">{
        return r.body.Write(b)
}</span>

// Reset clears the recorder for reuse
func (r *responseRecorder) Reset() <span class="cov0" title="0">{
        r.statusCode = http.StatusOK
        r.body.Reset()
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package middleware

import (
        "context"
        "net/http"

        "api-gateway/internal/config"
        "api-gateway/pkg/logger"

        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/exporters/jaeger"
        "go.opentelemetry.io/otel/propagation"
        "go.opentelemetry.io/otel/sdk/resource"
        sdktrace "go.opentelemetry.io/otel/sdk/trace"
        semconv "go.opentelemetry.io/otel/semconv/v1.16.0"
        "go.opentelemetry.io/otel/trace"
)

// TracingMiddleware provides distributed tracing functionality
type TracingMiddleware struct {
        config      *config.TracingConfig
        log         logger.Logger
        tracer      trace.Tracer
        tp          *sdktrace.TracerProvider
        initialized bool
}

// NewTracingMiddleware creates a new tracing middleware
func NewTracingMiddleware(config *config.TracingConfig, log logger.Logger) *TracingMiddleware <span class="cov0" title="0">{
        tm := &amp;TracingMiddleware{
                config: config,
                log:    log,
        }

        // Only initialize if tracing is enabled
        if config.Enabled </span><span class="cov0" title="0">{
                if err := tm.initialize(); err != nil </span><span class="cov0" title="0">{
                        log.Error("Failed to initialize tracing", logger.Error(err))
                }</span>
        }

        <span class="cov0" title="0">return tm</span>
}

// Initialize sets up the tracer provider
func (t *TracingMiddleware) initialize() error <span class="cov0" title="0">{
        // Create Jaeger exporter
        exp, err := jaeger.New(jaeger.WithCollectorEndpoint(jaeger.WithEndpoint(t.config.Endpoint)))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create tracer provider
        <span class="cov0" title="0">tp := sdktrace.NewTracerProvider(
                sdktrace.WithBatcher(exp),
                sdktrace.WithResource(resource.NewWithAttributes(
                        semconv.SchemaURL,
                        semconv.ServiceNameKey.String(t.config.ServiceName),
                )),
                sdktrace.WithSampler(sdktrace.TraceIDRatioBased(t.config.SampleRate)),
        )

        // Set global tracer provider
        otel.SetTracerProvider(tp)

        // Set global propagator
        otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(
                propagation.TraceContext{},
                propagation.Baggage{},
        ))

        // Create tracer
        t.tracer = tp.Tracer("api-gateway")
        t.tp = tp
        t.initialized = true

        t.log.Info("Tracing initialized",
                logger.String("provider", t.config.Provider),
                logger.String("endpoint", t.config.Endpoint),
                logger.String("service", t.config.ServiceName),
                logger.Any("sample_rate", t.config.SampleRate),
        )

        return nil</span>
}

// Tracing middleware adds distributed tracing to requests
func (t *TracingMiddleware) Tracing(next http.Handler) http.Handler <span class="cov0" title="0">{
        if !t.config.Enabled || !t.initialized </span><span class="cov0" title="0">{
                return next
        }</span>

        <span class="cov0" title="0">return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Extract context from request headers
                ctx := r.Context()
                ctx = otel.GetTextMapPropagator().Extract(ctx, propagation.HeaderCarrier(r.Header))

                // Start a new span
                spanName := r.Method + " " + r.URL.Path
                ctx, span := t.tracer.Start(ctx, spanName, trace.WithSpanKind(trace.SpanKindServer))
                defer span.End()

                // Add attributes to the span
                span.SetAttributes(
                        attribute.String("http.method", r.Method),
                        attribute.String("http.url", r.URL.String()),
                        attribute.String("http.host", r.Host),
                        attribute.String("http.user_agent", r.UserAgent()),
                )

                // Create a response writer that captures the status code
                recorder := &amp;responseRecorder{
                        ResponseWriter: w,
                        statusCode:     http.StatusOK,
                }

                // Process the request with the new context
                next.ServeHTTP(recorder, r.WithContext(ctx))

                // Add status code to span
                span.SetAttributes(attribute.Int("http.status_code", recorder.statusCode))

                // Mark as error if status code is 5xx
                if recorder.statusCode &gt;= 500 </span><span class="cov0" title="0">{
                        span.SetAttributes(attribute.Bool("error", true))
                }</span>
        })
}

// Shutdown cleanly shuts down the tracer provider
func (t *TracingMiddleware) Shutdown(ctx context.Context) error <span class="cov0" title="0">{
        if t.config.Enabled &amp;&amp; t.initialized &amp;&amp; t.tp != nil </span><span class="cov0" title="0">{
                return t.tp.Shutdown(ctx)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package middleware

import (
        "net/http"
        "regexp"

        "api-gateway/internal/config"
        "api-gateway/pkg/logger"
)

// URLRewriter provides URL rewriting functionality
type URLRewriter struct {
        log logger.Logger
}

// NewURLRewriter creates a new URL rewriting middleware
func NewURLRewriter(log logger.Logger) *URLRewriter <span class="cov0" title="0">{
        return &amp;URLRewriter{
                log: log,
        }
}</span>

// Rewrite applies URL rewriting patterns to requests
func (u *URLRewriter) Rewrite(next http.Handler, rewriteConfig *config.URLRewrite) http.Handler <span class="cov0" title="0">{
        // Compile all regex patterns at initialization
        var patterns []*rewritePattern
        if rewriteConfig != nil </span><span class="cov0" title="0">{
                for _, p := range rewriteConfig.Patterns </span><span class="cov0" title="0">{
                        regex, err := regexp.Compile(p.Match)
                        if err != nil </span><span class="cov0" title="0">{
                                u.log.Error("Failed to compile URL rewrite pattern",
                                        logger.String("pattern", p.Match),
                                        logger.Error(err),
                                )
                                continue</span>
                        }
                        <span class="cov0" title="0">patterns = append(patterns, &amp;rewritePattern{
                                regex:       regex,
                                replacement: p.Replacement,
                        })</span>
                }
        }

        // If no valid patterns, just pass through
        <span class="cov0" title="0">if len(patterns) == 0 </span><span class="cov0" title="0">{
                return next
        }</span>

        <span class="cov0" title="0">return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                originalPath := r.URL.Path

                // Apply each rewrite pattern
                for _, pattern := range patterns </span><span class="cov0" title="0">{
                        if pattern.regex.MatchString(r.URL.Path) </span><span class="cov0" title="0">{
                                newPath := pattern.regex.ReplaceAllString(r.URL.Path, pattern.replacement)
                                r.URL.Path = newPath

                                u.log.Debug("URL rewritten",
                                        logger.String("original", originalPath),
                                        logger.String("rewritten", newPath),
                                )

                                // We only apply the first matching pattern
                                break</span>
                        }
                }

                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}

// rewritePattern represents a compiled rewrite pattern
type rewritePattern struct {
        regex       *regexp.Regexp
        replacement string
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package proxy

import (
        "errors"
        "net/http"
        "sync"
        "time"

        "api-gateway/pkg/logger"
)

// CircuitBreakerState represents the state of a circuit breaker
type CircuitBreakerState int

const (
        // Closed means the circuit breaker is closed (allowing traffic)
        Closed CircuitBreakerState = iota
        // Open means the circuit breaker is open (blocking traffic)
        Open
        // HalfOpen means the circuit breaker is allowing a test request
        HalfOpen
)

// CircuitBreakerConfig contains configuration for a circuit breaker
type CircuitBreakerConfig struct {
        // Threshold is the number of consecutive failures before opening the circuit
        Threshold int
        // Timeout is the duration to wait before transitioning from Open to HalfOpen
        Timeout time.Duration
        // MaxConcurrent is the maximum number of concurrent requests (optional)
        MaxConcurrent int
}

// DefaultCircuitBreakerConfig returns a default circuit breaker configuration
func DefaultCircuitBreakerConfig() CircuitBreakerConfig <span class="cov0" title="0">{
        return CircuitBreakerConfig{
                Threshold:     5,
                Timeout:       30 * time.Second,
                MaxConcurrent: 100,
        }
}</span>

// CircuitBreaker implements the circuit breaker pattern
type CircuitBreaker struct {
        name          string
        state         CircuitBreakerState
        config        CircuitBreakerConfig
        failures      int
        lastFailure   time.Time
        mutex         sync.RWMutex
        inFlight      int
        inFlightMutex sync.Mutex
        log           logger.Logger
}

// NewCircuitBreaker creates a new circuit breaker
func NewCircuitBreaker(name string, config CircuitBreakerConfig, log logger.Logger) *CircuitBreaker <span class="cov0" title="0">{
        if config.Threshold &lt;= 0 </span><span class="cov0" title="0">{
                config.Threshold = 5
        }</span>
        <span class="cov0" title="0">if config.Timeout &lt;= 0 </span><span class="cov0" title="0">{
                config.Timeout = 30 * time.Second
        }</span>

        <span class="cov0" title="0">return &amp;CircuitBreaker{
                name:        name,
                state:       Closed,
                config:      config,
                failures:    0,
                lastFailure: time.Time{},
                log:         log,
        }</span>
}

// Execute executes a function with circuit breaker protection
func (cb *CircuitBreaker) Execute(req *http.Request, next http.Handler, w http.ResponseWriter) error <span class="cov0" title="0">{
        // Check if the circuit is open
        if !cb.AllowRequest() </span><span class="cov0" title="0">{
                cb.log.Debug("Circuit breaker open, request rejected",
                        logger.String("circuit", cb.name),
                        logger.String("path", req.URL.Path),
                )
                http.Error(w, "Service unavailable", http.StatusServiceUnavailable)
                return errors.New("circuit open")
        }</span>

        // Increment in-flight requests
        <span class="cov0" title="0">if !cb.acquireSemaphore() </span><span class="cov0" title="0">{
                cb.log.Debug("Circuit breaker max concurrent requests exceeded",
                        logger.String("circuit", cb.name),
                        logger.String("path", req.URL.Path),
                )
                http.Error(w, "Too many requests", http.StatusTooManyRequests)
                return errors.New("max concurrent requests")
        }</span>

        // Decrement in-flight requests when done
        <span class="cov0" title="0">defer cb.releaseSemaphore()

        // Create a custom response writer to capture status code
        crw := &amp;customResponseWriter{ResponseWriter: w, statusCode: http.StatusOK}

        // Process the request
        next.ServeHTTP(crw, req)

        // If status code indicates a server error, record a failure
        if crw.statusCode &gt;= 500 </span><span class="cov0" title="0">{
                cb.RecordFailure()
        }</span> else<span class="cov0" title="0"> {
                cb.RecordSuccess()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// AllowRequest checks if a request should be allowed based on circuit state
func (cb *CircuitBreaker) AllowRequest() bool <span class="cov0" title="0">{
        cb.mutex.RLock()
        state := cb.state
        cb.mutex.RUnlock()

        switch state </span>{
        case Closed:<span class="cov0" title="0">
                // Circuit is closed, requests are allowed
                return true</span>
        case Open:<span class="cov0" title="0">
                // Check if timeout has elapsed to try a test request
                cb.mutex.Lock()
                defer cb.mutex.Unlock()

                // If timeout has elapsed, transition to half-open
                if time.Since(cb.lastFailure) &gt; cb.config.Timeout </span><span class="cov0" title="0">{
                        cb.state = HalfOpen
                        cb.log.Info("Circuit breaker transitioned to half-open",
                                logger.String("circuit", cb.name),
                        )
                        return true
                }</span>

                <span class="cov0" title="0">return false</span>
        case HalfOpen:<span class="cov0" title="0">
                // In half-open state, allow only one request for testing
                cb.mutex.RLock()
                defer cb.mutex.RUnlock()
                return true</span>
        default:<span class="cov0" title="0">
                return true</span>
        }
}

// RecordSuccess records a successful request
func (cb *CircuitBreaker) RecordSuccess() <span class="cov0" title="0">{
        cb.mutex.Lock()
        defer cb.mutex.Unlock()

        switch cb.state </span>{
        case HalfOpen:<span class="cov0" title="0">
                // If successful in half-open state, close the circuit
                cb.failures = 0
                cb.state = Closed
                cb.log.Info("Circuit breaker closed after successful test request",
                        logger.String("circuit", cb.name),
                )</span>
        case Closed:<span class="cov0" title="0">
                // Reset failure count in closed state
                cb.failures = 0</span>
        }
}

// RecordFailure records a failed request
func (cb *CircuitBreaker) RecordFailure() <span class="cov0" title="0">{
        cb.mutex.Lock()
        defer cb.mutex.Unlock()

        cb.lastFailure = time.Now()

        switch cb.state </span>{
        case HalfOpen:<span class="cov0" title="0">
                // If failed in half-open state, open the circuit again
                cb.state = Open
                cb.log.Warn("Circuit breaker reopened after failed test request",
                        logger.String("circuit", cb.name),
                )</span>
        case Closed:<span class="cov0" title="0">
                // Increment failures in closed state
                cb.failures++

                // If failures exceed threshold, open the circuit
                if cb.failures &gt;= cb.config.Threshold </span><span class="cov0" title="0">{
                        cb.state = Open
                        cb.log.Warn("Circuit breaker opened after consecutive failures",
                                logger.String("circuit", cb.name),
                                logger.Int("failures", cb.failures),
                        )
                }</span>
        }
}

// acquireSemaphore attempts to acquire a semaphore for concurrent request limiting
func (cb *CircuitBreaker) acquireSemaphore() bool <span class="cov0" title="0">{
        if cb.config.MaxConcurrent &lt;= 0 </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">cb.inFlightMutex.Lock()
        defer cb.inFlightMutex.Unlock()

        if cb.inFlight &gt;= cb.config.MaxConcurrent </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">cb.inFlight++
        return true</span>
}

// releaseSemaphore releases a semaphore
func (cb *CircuitBreaker) releaseSemaphore() <span class="cov0" title="0">{
        if cb.config.MaxConcurrent &lt;= 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">cb.inFlightMutex.Lock()
        defer cb.inFlightMutex.Unlock()

        if cb.inFlight &gt; 0 </span><span class="cov0" title="0">{
                cb.inFlight--
        }</span>
}

// customResponseWriter is a wrapper around http.ResponseWriter that captures the status code
type customResponseWriter struct {
        http.ResponseWriter
        statusCode int
}

// WriteHeader captures the status code
func (crw *customResponseWriter) WriteHeader(statusCode int) <span class="cov0" title="0">{
        crw.statusCode = statusCode
        crw.ResponseWriter.WriteHeader(statusCode)
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package proxy

import (
        "net/http"
        "net/http/httputil"
        "net/url"
        "strings"
        "time"

        "api-gateway/internal/config"
        "api-gateway/pkg/logger"
)

// HTTPProxy handles HTTP requests to upstream services
type HTTPProxy struct {
        config *config.Config
        routes *config.RouteConfig
        log    logger.Logger
        // Map to store circuit breakers for routes
        circuitBreakers map[string]*CircuitBreaker
}

// NewHTTPProxy creates a new HTTP proxy
func NewHTTPProxy(config *config.Config, routes *config.RouteConfig, log logger.Logger) *HTTPProxy <span class="cov0" title="0">{
        return &amp;HTTPProxy{
                config:          config,
                routes:          routes,
                log:             log,
                circuitBreakers: make(map[string]*CircuitBreaker),
        }
}</span>

// ProxyRequest forwards the request to the upstream service
func (p *HTTPProxy) ProxyRequest(route config.Route) http.Handler <span class="cov0" title="0">{
        // Parse the upstream URL
        target, err := url.Parse(route.Upstream)
        if err != nil </span><span class="cov0" title="0">{
                p.log.Error("Failed to parse upstream URL",
                        logger.String("upstream", route.Upstream),
                        logger.Error(err),
                )
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        http.Error(w, "Internal server error", http.StatusInternalServerError)
                }</span>)
        }

        // Create load balancer if configured
        <span class="cov0" title="0">var loadBalancer *LoadBalancer
        if route.LoadBalancing != nil &amp;&amp; len(route.LoadBalancing.Endpoints) &gt; 0 </span><span class="cov0" title="0">{
                loadBalancer, err = NewLoadBalancer(route.LoadBalancing, p.log)
                if err != nil </span><span class="cov0" title="0">{
                        p.log.Error("Failed to create load balancer",
                                logger.String("path", route.Path),
                                logger.Error(err),
                        )
                }</span> else<span class="cov0" title="0"> {
                        p.log.Info("Created load balancer for route",
                                logger.String("path", route.Path),
                                logger.String("method", route.LoadBalancing.Method),
                                logger.Int("endpoints", len(route.LoadBalancing.Endpoints)),
                        )
                }</span>
        }

        // Create a proxy handler factory function that can select the target
        <span class="cov0" title="0">createProxy := func(targetURL *url.URL) *httputil.ReverseProxy </span><span class="cov0" title="0">{
                proxy := httputil.NewSingleHostReverseProxy(targetURL)

                // Customize the director function to modify the request
                originalDirector := proxy.Director
                proxy.Director = func(req *http.Request) </span><span class="cov0" title="0">{
                        // Call the original director
                        originalDirector(req)

                        // Modify the request URL
                        req.URL.Scheme = targetURL.Scheme
                        req.URL.Host = targetURL.Host

                        // Handle path stripping if enabled
                        if route.StripPrefix &amp;&amp; strings.HasPrefix(req.URL.Path, route.Path) </span><span class="cov0" title="0">{
                                // Remove the route path prefix from the URL
                                req.URL.Path = strings.TrimPrefix(req.URL.Path, route.Path)
                                if req.URL.Path == "" </span><span class="cov0" title="0">{
                                        req.URL.Path = "/"
                                }</span>
                        }

                        // Update the Host header to match the target
                        <span class="cov0" title="0">req.Host = targetURL.Host

                        // Add X-Forwarded headers
                        if _, ok := req.Header["X-Forwarded-For"]; !ok </span><span class="cov0" title="0">{
                                req.Header.Set("X-Forwarded-For", req.RemoteAddr)
                        }</span>
                        <span class="cov0" title="0">req.Header.Set("X-Forwarded-Host", req.Host)
                        req.Header.Set("X-Forwarded-Proto", req.URL.Scheme)
                        req.Header.Set("X-Gateway-Proxy", "true")</span>
                }

                // Customize the error handler
                <span class="cov0" title="0">proxy.ErrorHandler = func(w http.ResponseWriter, r *http.Request, err error) </span><span class="cov0" title="0">{
                        p.log.Error("Proxy error",
                                logger.String("path", r.URL.Path),
                                logger.String("method", r.Method),
                                logger.String("upstream", targetURL.String()),
                                logger.Error(err),
                        )
                        http.Error(w, "Service unavailable", http.StatusServiceUnavailable)
                }</span>

                // Set timeouts
                <span class="cov0" title="0">if route.Timeout &gt; 0 </span><span class="cov0" title="0">{
                        timeout := time.Duration(route.Timeout) * time.Second
                        proxy.Transport = &amp;http.Transport{
                                ResponseHeaderTimeout: timeout,
                                ExpectContinueTimeout: 1 * time.Second,
                                MaxIdleConns:          100,
                                MaxIdleConnsPerHost:   100,
                                IdleConnTimeout:       90 * time.Second,
                        }
                }</span>

                <span class="cov0" title="0">return proxy</span>
        }

        // Create the final handler
        <span class="cov0" title="0">proxyHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Select target - either from load balancer or static
                targetURL := target
                if loadBalancer != nil </span><span class="cov0" title="0">{
                        targetURL = loadBalancer.GetEndpoint()
                        p.log.Debug("Using load balanced endpoint",
                                logger.String("path", r.URL.Path),
                                logger.String("endpoint", targetURL.String()),
                        )
                }</span>

                // Create or get proxy for this target
                <span class="cov0" title="0">proxy := createProxy(targetURL)

                // Log the request
                p.log.Debug("Proxying request",
                        logger.String("path", r.URL.Path),
                        logger.String("method", r.Method),
                        logger.String("upstream", targetURL.String()),
                )

                // Proxy the request to the upstream service
                proxy.ServeHTTP(w, r)</span>
        })

        // Apply circuit breaker if enabled
        <span class="cov0" title="0">if route.CircuitBreaker != nil &amp;&amp; route.CircuitBreaker.Enabled </span><span class="cov0" title="0">{
                // Create circuit breaker key - unique per route
                circuitKey := route.Path

                // Get or create circuit breaker for this route
                cb, exists := p.circuitBreakers[circuitKey]
                if !exists </span><span class="cov0" title="0">{
                        // Create circuit breaker config
                        cbConfig := CircuitBreakerConfig{
                                Threshold:     route.CircuitBreaker.Threshold,
                                Timeout:       time.Duration(route.CircuitBreaker.Timeout) * time.Second,
                                MaxConcurrent: route.CircuitBreaker.MaxConcurrent,
                        }

                        // Create a new circuit breaker
                        cb = NewCircuitBreaker(circuitKey, cbConfig, p.log)
                        p.circuitBreakers[circuitKey] = cb

                        p.log.Info("Created circuit breaker for route",
                                logger.String("path", route.Path),
                                logger.Int("threshold", route.CircuitBreaker.Threshold),
                                logger.Int("timeout", route.CircuitBreaker.Timeout),
                        )
                }</span>

                // Wrap the proxy handler with circuit breaker
                <span class="cov0" title="0">return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        // Execute the request through the circuit breaker
                        if err := cb.Execute(r, proxyHandler, w); err != nil </span><span class="cov0" title="0">{
                                // Error is already handled inside the Execute method
                                return
                        }</span>
                })
        }

        // Return the standard proxy handler if circuit breaker is not enabled
        <span class="cov0" title="0">return proxyHandler</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package proxy

import (
        "math/rand"
        "net/http"
        "net/url"
        "sync"
        "sync/atomic"
        "time"

        "api-gateway/internal/config"
        "api-gateway/pkg/logger"
)

// LoadBalancer provides load balancing functionality
type LoadBalancer struct {
        config     *config.LoadBalancingConfig
        endpoints  []*url.URL
        counter    uint64
        healthMap  map[string]bool
        healthLock sync.RWMutex
        log        logger.Logger
}

// NewLoadBalancer creates a new load balancer
func NewLoadBalancer(config *config.LoadBalancingConfig, log logger.Logger) (*LoadBalancer, error) <span class="cov0" title="0">{
        if config == nil || len(config.Endpoints) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">var endpoints []*url.URL
        for _, endpoint := range config.Endpoints </span><span class="cov0" title="0">{
                url, err := url.Parse(endpoint)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("Failed to parse load balancer endpoint",
                                logger.String("endpoint", endpoint),
                                logger.Error(err),
                        )
                        continue</span>
                }
                <span class="cov0" title="0">endpoints = append(endpoints, url)</span>
        }

        <span class="cov0" title="0">if len(endpoints) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">lb := &amp;LoadBalancer{
                config:    config,
                endpoints: endpoints,
                counter:   0,
                healthMap: make(map[string]bool),
                log:       log,
        }

        // Initialize all endpoints as healthy
        for _, endpoint := range endpoints </span><span class="cov0" title="0">{
                lb.healthMap[endpoint.String()] = true
        }</span>

        // Start health checking if enabled
        <span class="cov0" title="0">if config.HealthCheck </span><span class="cov0" title="0">{
                go lb.startHealthCheck()
        }</span>

        <span class="cov0" title="0">return lb, nil</span>
}

// GetEndpoint returns the next endpoint based on the load balancing strategy
func (lb *LoadBalancer) GetEndpoint() *url.URL <span class="cov0" title="0">{
        // First check if we have any healthy endpoints
        healthyEndpoints := lb.getHealthyEndpoints()
        if len(healthyEndpoints) == 0 </span><span class="cov0" title="0">{
                // If no healthy endpoints, return any endpoint (better than nothing)
                return lb.getAnyEndpoint()
        }</span>

        // Select endpoint based on strategy
        <span class="cov0" title="0">switch lb.config.Method </span>{
        case "random":<span class="cov0" title="0">
                return lb.getRandomEndpoint(healthyEndpoints)</span>
        case "round_robin":<span class="cov0" title="0">
                return lb.getRoundRobinEndpoint(healthyEndpoints)</span>
        default:<span class="cov0" title="0">
                // Default to round-robin
                return lb.getRoundRobinEndpoint(healthyEndpoints)</span>
        }
}

// getHealthyEndpoints returns only the healthy endpoints
func (lb *LoadBalancer) getHealthyEndpoints() []*url.URL <span class="cov0" title="0">{
        lb.healthLock.RLock()
        defer lb.healthLock.RUnlock()

        var healthy []*url.URL
        for _, endpoint := range lb.endpoints </span><span class="cov0" title="0">{
                if lb.healthMap[endpoint.String()] </span><span class="cov0" title="0">{
                        healthy = append(healthy, endpoint)
                }</span>
        }
        <span class="cov0" title="0">return healthy</span>
}

// getAnyEndpoint returns any endpoint regardless of health status
func (lb *LoadBalancer) getAnyEndpoint() *url.URL <span class="cov0" title="0">{
        // Just use round-robin on all endpoints
        count := atomic.AddUint64(&amp;lb.counter, 1)
        return lb.endpoints[count%uint64(len(lb.endpoints))]
}</span>

// getRandomEndpoint returns a random endpoint from the given list
func (lb *LoadBalancer) getRandomEndpoint(endpoints []*url.URL) *url.URL <span class="cov0" title="0">{
        return endpoints[rand.Intn(len(endpoints))]
}</span>

// getRoundRobinEndpoint returns the next endpoint in round-robin fashion
func (lb *LoadBalancer) getRoundRobinEndpoint(endpoints []*url.URL) *url.URL <span class="cov0" title="0">{
        count := atomic.AddUint64(&amp;lb.counter, 1)
        return endpoints[count%uint64(len(endpoints))]
}</span>

// startHealthCheck periodically checks the health of all endpoints
func (lb *LoadBalancer) startHealthCheck() <span class="cov0" title="0">{
        ticker := time.NewTicker(10 * time.Second)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                &lt;-ticker.C
                lb.checkEndpointsHealth()
        }</span>
}

// checkEndpointsHealth checks the health of all endpoints
func (lb *LoadBalancer) checkEndpointsHealth() <span class="cov0" title="0">{
        for _, endpoint := range lb.endpoints </span><span class="cov0" title="0">{
                go lb.checkEndpointHealth(endpoint)
        }</span>
}

// checkEndpointHealth checks the health of a single endpoint
func (lb *LoadBalancer) checkEndpointHealth(endpoint *url.URL) <span class="cov0" title="0">{
        // Create a health check URL (often /health or /status)
        healthURL := *endpoint
        healthURL.Path = "/health"

        // Create a client with short timeout
        client := &amp;http.Client{
                Timeout: 2 * time.Second,
        }

        // Make the request
        resp, err := client.Get(healthURL.String())

        // Update health status
        lb.healthLock.Lock()
        defer lb.healthLock.Unlock()

        // Mark as healthy if no error and status is 2xx
        isHealthy := err == nil &amp;&amp; resp != nil &amp;&amp; resp.StatusCode &gt;= 200 &amp;&amp; resp.StatusCode &lt; 300

        // Only log if status changes
        if lb.healthMap[endpoint.String()] != isHealthy </span><span class="cov0" title="0">{
                if isHealthy </span><span class="cov0" title="0">{
                        lb.log.Info("Endpoint is now healthy",
                                logger.String("endpoint", endpoint.String()),
                        )
                }</span> else<span class="cov0" title="0"> {
                        lb.log.Warn("Endpoint is unhealthy",
                                logger.String("endpoint", endpoint.String()),
                                logger.Error(err),
                        )
                }</span>
        }

        <span class="cov0" title="0">lb.healthMap[endpoint.String()] = isHealthy

        // Close response body if not nil
        if resp != nil </span><span class="cov0" title="0">{
                resp.Body.Close()
        }</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package proxy

import (
        "fmt"
        "io"
        "net/http"
        "net/url"
        "strings"

        "api-gateway/internal/config"
        "api-gateway/pkg/logger"

        "github.com/gorilla/websocket"
)

// WSProxy handles WebSocket connections to upstream services
type WSProxy struct {
        config *config.Config
        routes *config.RouteConfig
        log    logger.Logger
        // Websocket upgrader
        upgrader websocket.Upgrader
}

// NewWSProxy creates a new WebSocket proxy
func NewWSProxy(config *config.Config, routes *config.RouteConfig, log logger.Logger) *WSProxy <span class="cov0" title="0">{
        return &amp;WSProxy{
                config: config,
                routes: routes,
                log:    log,
                upgrader: websocket.Upgrader{
                        ReadBufferSize:  1024,
                        WriteBufferSize: 1024,
                        // Allow all origins
                        CheckOrigin: func(r *http.Request) bool </span><span class="cov0" title="0">{ return true }</span>,
                },
        }
}

// ProxyWebSocket handles WebSocket proxy requests
func (p *WSProxy) ProxyWebSocket(route config.Route) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if route.WebSocket == nil || !route.WebSocket.Enabled </span><span class="cov0" title="0">{
                        http.Error(w, "WebSocket not enabled for this route", http.StatusBadRequest)
                        return
                }</span>

                // Parse the upstream URL
                <span class="cov0" title="0">upstreamURL, err := url.Parse(route.Upstream)
                if err != nil </span><span class="cov0" title="0">{
                        p.log.Error("Failed to parse upstream URL",
                                logger.String("upstream", route.Upstream),
                                logger.Error(err),
                        )
                        http.Error(w, "Internal server error", http.StatusInternalServerError)
                        return
                }</span>

                // Determine the WebSocket path
                <span class="cov0" title="0">wsPath := route.WebSocket.UpstreamPath
                if wsPath == "" </span><span class="cov0" title="0">{
                        // If no specific upstream path is provided, use the same path
                        wsPath = r.URL.Path
                        if route.StripPrefix &amp;&amp; strings.HasPrefix(wsPath, route.Path) </span><span class="cov0" title="0">{
                                // Strip the route prefix if needed
                                wsPath = strings.TrimPrefix(wsPath, route.Path)
                                if wsPath == "" </span><span class="cov0" title="0">{
                                        wsPath = "/"
                                }</span>
                        }
                }

                // Form the WebSocket URL
                <span class="cov0" title="0">wsURL := url.URL{
                        Scheme: convertHttpSchemeToWs(upstreamURL.Scheme),
                        Host:   upstreamURL.Host,
                        Path:   wsPath,
                }

                // Add query parameters if any
                if r.URL.RawQuery != "" </span><span class="cov0" title="0">{
                        wsURL.RawQuery = r.URL.RawQuery
                }</span>

                <span class="cov0" title="0">p.log.Debug("Upgrading to WebSocket connection",
                        logger.String("upstream", wsURL.String()),
                )

                // Upgrade the client connection
                clientConn, err := p.upgrader.Upgrade(w, r, nil)
                if err != nil </span><span class="cov0" title="0">{
                        p.log.Error("Failed to upgrade client connection", logger.Error(err))
                        return
                }</span>
                <span class="cov0" title="0">defer clientConn.Close()

                // Copy headers for upstream connection
                headers := http.Header{}
                for k, vs := range r.Header </span><span class="cov0" title="0">{
                        if k == "Connection" || k == "Sec-Websocket-Key" ||
                                k == "Sec-Websocket-Version" || k == "Sec-Websocket-Extensions" ||
                                k == "Sec-Websocket-Protocol" || k == "Upgrade" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">for _, v := range vs </span><span class="cov0" title="0">{
                                headers.Add(k, v)
                        }</span>
                }

                <span class="cov0" title="0">headers.Set("Host", upstreamURL.Host)
                headers.Set("Origin", fmt.Sprintf("%s://%s", upstreamURL.Scheme, upstreamURL.Host))

                // Add custom headers
                headers.Set("X-Forwarded-For", r.RemoteAddr)
                headers.Set("X-Forwarded-Host", r.Host)
                headers.Set("X-Gateway-Proxy", "true")

                // Connect to upstream WebSocket
                p.log.Debug("Connecting to upstream WebSocket",
                        logger.String("url", wsURL.String()),
                )
                upstreamConn, _, err := websocket.DefaultDialer.Dial(wsURL.String(), headers)
                if err != nil </span><span class="cov0" title="0">{
                        p.log.Error("Failed to connect to upstream WebSocket", logger.Error(err))
                        clientConn.WriteMessage(websocket.CloseMessage,
                                websocket.FormatCloseMessage(websocket.CloseInternalServerErr, "Cannot connect to service"))
                        return
                }</span>
                <span class="cov0" title="0">defer upstreamConn.Close()

                p.log.Debug("WebSocket connection established",
                        logger.String("path", r.URL.Path),
                        logger.String("upstream", wsURL.String()),
                )

                // Bidirectional copy
                errorChan := make(chan error, 2)

                // Client to upstream
                go p.proxyWebSocketConn(clientConn, upstreamConn, errorChan)

                // Upstream to client
                go p.proxyWebSocketConn(upstreamConn, clientConn, errorChan)

                // Wait for an error in either direction
                err = &lt;-errorChan
                if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                        p.log.Error("WebSocket proxy error", logger.Error(err))
                }</span>

                <span class="cov0" title="0">p.log.Debug("WebSocket connection closed",
                        logger.String("path", r.URL.Path),
                )</span>
        })
}

// proxyWebSocketConn copies messages from one connection to another
func (p *WSProxy) proxyWebSocketConn(src, dst *websocket.Conn, errChan chan error) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                messageType, message, err := src.ReadMessage()
                if err != nil </span><span class="cov0" title="0">{
                        // Don't log EOF as error - it's normal when connection closes
                        if err != io.EOF &amp;&amp; !websocket.IsCloseError(err, websocket.CloseNormalClosure, websocket.CloseGoingAway) </span><span class="cov0" title="0">{
                                errChan &lt;- fmt.Errorf("error reading from WebSocket: %w", err)
                        }</span> else<span class="cov0" title="0"> {
                                errChan &lt;- io.EOF
                        }</span>
                        <span class="cov0" title="0">break</span>
                }

                <span class="cov0" title="0">if err := dst.WriteMessage(messageType, message); err != nil </span><span class="cov0" title="0">{
                        errChan &lt;- fmt.Errorf("error writing to WebSocket: %w", err)
                        break</span>
                }
        }
}

// convertHttpSchemeToWs converts HTTP/HTTPS scheme to WS/WSS
func convertHttpSchemeToWs(scheme string) string <span class="cov0" title="0">{
        scheme = strings.ToLower(scheme)
        if scheme == "https" </span><span class="cov0" title="0">{
                return "wss"
        }</span>
        <span class="cov0" title="0">return "ws"</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package server

import (
        "context"
        "fmt"
        "net/http"
        "time"

        "api-gateway/internal/auth"
        "api-gateway/internal/config"
        "api-gateway/internal/handlers"
        "api-gateway/internal/middleware"
        "api-gateway/internal/proxy"
        "api-gateway/pkg/logger"

        "github.com/gorilla/mux"
)

// Server represents the API Gateway server
type Server struct {
        config            *config.Config
        routes            *config.RouteConfig
        log               logger.Logger
        httpServer        *http.Server
        router            *mux.Router
        authService       *auth.AuthService
        httpProxy         *proxy.HTTPProxy
        wsProxy           *proxy.WSProxy
        authMiddleware    *middleware.AuthMiddleware
        cacheMiddleware   *middleware.CacheMiddleware
        rateLimiter       *middleware.RateLimiter
        headerTransformer *middleware.HeaderTransformer
        urlRewriter       *middleware.URLRewriter
        retryMiddleware   *middleware.RetryMiddleware
        metricsMiddleware *middleware.MetricsMiddleware
}

// NewServer creates a new server instance
func NewServer(cfg *config.Config, routes *config.RouteConfig, log logger.Logger) *Server <span class="cov0" title="0">{
        router := mux.NewRouter()

        // Initialize services
        authService := auth.NewAuthService(&amp;cfg.Auth, log)
        httpProxy := proxy.NewHTTPProxy(cfg, routes, log)
        wsProxy := proxy.NewWSProxy(cfg, routes, log)

        // Initialize middleware
        authMiddleware := middleware.NewAuthMiddleware(authService, &amp;cfg.Auth, log)
        cacheMiddleware := middleware.NewCacheMiddleware(&amp;cfg.Cache, log)
        rateLimiter := middleware.NewRateLimiter(log)
        headerTransformer := middleware.NewHeaderTransformer(log)
        urlRewriter := middleware.NewURLRewriter(log)
        retryMiddleware := middleware.NewRetryMiddleware(log)
        metricsMiddleware := middleware.NewMetricsMiddleware(&amp;cfg.Metrics, log)

        // Setup rate limiters for routes with rate limiting enabled
        for _, route := range routes.Routes </span><span class="cov0" title="0">{
                if route.RateLimit != nil &amp;&amp; route.RateLimit.Requests &gt; 0 </span><span class="cov0" title="0">{
                        rateLimiter.AddLimit(route.Path, *route.RateLimit)
                }</span>
        }

        // Create HTTP server
        <span class="cov0" title="0">httpServer := &amp;http.Server{
                Addr:         cfg.Server.Address,
                Handler:      router,
                ReadTimeout:  time.Duration(cfg.Server.ReadTimeout) * time.Second,
                WriteTimeout: time.Duration(cfg.Server.WriteTimeout) * time.Second,
                IdleTimeout:  120 * time.Second,
        }

        return &amp;Server{
                config:            cfg,
                routes:            routes,
                log:               log,
                httpServer:        httpServer,
                router:            router,
                authService:       authService,
                httpProxy:         httpProxy,
                wsProxy:           wsProxy,
                authMiddleware:    authMiddleware,
                cacheMiddleware:   cacheMiddleware,
                rateLimiter:       rateLimiter,
                headerTransformer: headerTransformer,
                urlRewriter:       urlRewriter,
                retryMiddleware:   retryMiddleware,
                metricsMiddleware: metricsMiddleware,
        }</span>
}

// Start initializes and starts the server
func (s *Server) Start() error <span class="cov0" title="0">{
        // Register routes
        s.registerRoutes()

        // Apply global middleware
        var handler http.Handler = s.router

        // Add metrics middleware if enabled
        if s.config.Metrics.Enabled </span><span class="cov0" title="0">{
                handler = s.metricsMiddleware.Metrics(handler)
                handler = s.metricsMiddleware.RegisterMetricsEndpoint(handler)
        }</span>

        // Set the final handler
        <span class="cov0" title="0">s.httpServer.Handler = handler

        // Start HTTP server
        s.log.Info("Starting server", logger.String("address", s.config.Server.Address))
        if err := s.httpServer.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                s.log.Error("Failed to start server", logger.Error(err))
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Stop gracefully stops the server
func (s *Server) Stop(ctx context.Context) error <span class="cov0" title="0">{
        s.log.Info("Shutting down server...")
        return s.httpServer.Shutdown(ctx)
}</span>

// registerRoutes configures all the route handlers
func (s *Server) registerRoutes() <span class="cov0" title="0">{
        // Add health check endpoint
        s.router.HandleFunc("/health", handlers.HealthCheckHandler).Methods("GET")

        // Register all routes from configuration
        for _, route := range s.routes.Routes </span><span class="cov0" title="0">{
                s.registerRoute(route)
        }</span>

        // Add catch-all route for 404 responses
        <span class="cov0" title="0">s.router.NotFoundHandler = http.HandlerFunc(handlers.NotFoundHandler)</span>
}

// registerRoute configures an individual route
func (s *Server) registerRoute(route config.Route) <span class="cov0" title="0">{
        // Create a new router for this route
        routeRouter := s.router.PathPrefix(route.Path).Subrouter()

        // Register the appropriate handlers based on whether it's a WebSocket route or not
        if route.WebSocket != nil &amp;&amp; route.WebSocket.Enabled </span><span class="cov0" title="0">{
                // WebSocket handler
                wsHandler := s.wsProxy.ProxyWebSocket(route)

                // Apply authentication middleware if required
                if route.RequireAuth </span><span class="cov0" title="0">{
                        wsHandler = s.authMiddleware.Authenticate(wsHandler, route)
                }</span>

                // Register the handler for the WebSocket-specific path or the general route path
                <span class="cov0" title="0">wsPath := route.WebSocket.Path
                if wsPath == "" </span><span class="cov0" title="0">{
                        // If no specific path is provided, use the general path
                        routeRouter.PathPrefix("/").Handler(wsHandler)
                        s.log.Info("Registered WebSocket route",
                                logger.String("path", fmt.Sprintf("%s/*", route.Path)),
                                logger.String("upstream", route.Upstream),
                        )
                }</span> else<span class="cov0" title="0"> {
                        // Register handler for the specific WebSocket path
                        s.router.Path(wsPath).Handler(wsHandler)
                        s.log.Info("Registered WebSocket route",
                                logger.String("path", wsPath),
                                logger.String("upstream", route.Upstream),
                        )
                }</span>
        } else<span class="cov0" title="0"> {
                // HTTP handler
                httpHandler := s.httpProxy.ProxyRequest(route)

                // Apply URL rewriting if configured
                if route.URLRewrite != nil &amp;&amp; len(route.URLRewrite.Patterns) &gt; 0 </span><span class="cov0" title="0">{
                        httpHandler = s.urlRewriter.Rewrite(httpHandler, route.URLRewrite)
                        s.log.Info("Applied URL rewriting to route",
                                logger.String("path", route.Path),
                                logger.Int("patterns", len(route.URLRewrite.Patterns)),
                        )
                }</span>

                // Apply header transformations if configured
                <span class="cov0" title="0">if route.HeaderTransform != nil </span><span class="cov0" title="0">{
                        httpHandler = s.headerTransformer.Transform(httpHandler, route.HeaderTransform)
                        s.log.Info("Applied header transformation to route",
                                logger.String("path", route.Path),
                        )
                }</span>

                // Apply rate limiting if enabled
                <span class="cov0" title="0">if route.RateLimit != nil &amp;&amp; route.RateLimit.Requests &gt; 0 </span><span class="cov0" title="0">{
                        httpHandler = s.rateLimiter.RateLimit(httpHandler, route)
                        s.log.Info("Applied rate limiting to route",
                                logger.String("path", route.Path),
                                logger.Int("requests", route.RateLimit.Requests),
                                logger.String("period", route.RateLimit.Period),
                        )
                }</span>

                // Apply retry policy if enabled
                <span class="cov0" title="0">if route.RetryPolicy != nil &amp;&amp; route.RetryPolicy.Enabled </span><span class="cov0" title="0">{
                        httpHandler = s.retryMiddleware.Retry(httpHandler, route.RetryPolicy)
                        s.log.Info("Applied retry policy to route",
                                logger.String("path", route.Path),
                                logger.Int("attempts", route.RetryPolicy.Attempts),
                                logger.Int("per_try_timeout", route.RetryPolicy.PerTryTimeout),
                        )
                }</span>

                // Apply cache middleware if enabled for this route
                <span class="cov0" title="0">if s.config.Cache.Enabled &amp;&amp; route.Cache != nil &amp;&amp; route.Cache.Enabled </span><span class="cov0" title="0">{
                        httpHandler = s.cacheMiddleware.Cache(httpHandler, route)
                        s.log.Info("Applied cache middleware to route",
                                logger.String("path", route.Path),
                                logger.Int("ttl", route.Cache.TTL),
                                logger.Bool("cache_authenticated", route.Cache.CacheAuthenticated),
                        )
                }</span>

                // Apply authentication middleware if required
                <span class="cov0" title="0">if route.RequireAuth </span><span class="cov0" title="0">{
                        httpHandler = s.authMiddleware.Authenticate(httpHandler, route)
                }</span>

                // If methods are specified, register the handler for each method
                <span class="cov0" title="0">if len(route.Methods) &gt; 0 </span><span class="cov0" title="0">{
                        for _, method := range route.Methods </span><span class="cov0" title="0">{
                                routeRouter.PathPrefix("/").Handler(httpHandler).Methods(method)
                                s.log.Info("Registered route",
                                        logger.String("path", fmt.Sprintf("%s/*", route.Path)),
                                        logger.String("method", method),
                                        logger.String("upstream", route.Upstream),
                                )
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Otherwise, register for all methods
                        routeRouter.PathPrefix("/").Handler(httpHandler)
                        s.log.Info("Registered route",
                                logger.String("path", fmt.Sprintf("%s/*", route.Path)),
                                logger.String("method", "ALL"),
                                logger.String("upstream", route.Upstream),
                        )
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package logger

import (
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

// Logger interface defines the logging methods
type Logger interface {
        Debug(msg string, fields ...Field)
        Info(msg string, fields ...Field)
        Warn(msg string, fields ...Field)
        Error(msg string, fields ...Field)
        Fatal(msg string, fields ...Field)
}

// Field represents a log field
type Field struct {
        Key   string
        Value interface{}
}

// zapLogger implements the Logger interface using zap
type zapLogger struct {
        logger *zap.Logger
}

// NewLogger creates a new logger instance
func NewLogger() Logger <span class="cov0" title="0">{
        config := zap.NewProductionConfig()
        config.EncoderConfig.TimeKey = "timestamp"
        config.EncoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
        config.EncoderConfig.StacktraceKey = "stacktrace"

        logger, err := config.Build(zap.AddCallerSkip(1))
        if err != nil </span><span class="cov0" title="0">{
                panic("failed to initialize logger: " + err.Error())</span>
        }

        <span class="cov0" title="0">return &amp;zapLogger{
                logger: logger,
        }</span>
}

// Debug logs a debug message
func (l *zapLogger) Debug(msg string, fields ...Field) <span class="cov0" title="0">{
        l.logger.Debug(msg, l.convertFields(fields...)...)
}</span>

// Info logs an info message
func (l *zapLogger) Info(msg string, fields ...Field) <span class="cov0" title="0">{
        l.logger.Info(msg, l.convertFields(fields...)...)
}</span>

// Warn logs a warning message
func (l *zapLogger) Warn(msg string, fields ...Field) <span class="cov0" title="0">{
        l.logger.Warn(msg, l.convertFields(fields...)...)
}</span>

// Error logs an error message
func (l *zapLogger) Error(msg string, fields ...Field) <span class="cov0" title="0">{
        l.logger.Error(msg, l.convertFields(fields...)...)
}</span>

// Fatal logs a fatal message and terminates the program
func (l *zapLogger) Fatal(msg string, fields ...Field) <span class="cov0" title="0">{
        l.logger.Fatal(msg, l.convertFields(fields...)...)
}</span>

// convertFields converts logger.Field to zap.Field
func (l *zapLogger) convertFields(fields ...Field) []zap.Field <span class="cov0" title="0">{
        zapFields := make([]zap.Field, 0, len(fields))
        for _, field := range fields </span><span class="cov0" title="0">{
                zapFields = append(zapFields, zap.Any(field.Key, field.Value))
        }</span>
        <span class="cov0" title="0">return zapFields</span>
}

// Convenience functions to create fields
func String(key string, value string) Field <span class="cov0" title="0">{
        return Field{Key: key, Value: value}
}</span>

func Int(key string, value int) Field <span class="cov0" title="0">{
        return Field{Key: key, Value: value}
}</span>

func Error(err error) Field <span class="cov0" title="0">{
        return Field{Key: "error", Value: err.Error()}
}</span>

func Bool(key string, value bool) Field <span class="cov0" title="0">{
        return Field{Key: key, Value: value}
}</span>

func Any(key string, value interface{}) Field <span class="cov0" title="0">{
        return Field{Key: key, Value: value}
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package testutils

import (
        "api-gateway/pkg/logger"

        "context"

        "github.com/stretchr/testify/mock"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/codes"
        "go.opentelemetry.io/otel/trace"
)

// MockLogger is a mock implementation of the logger.Logger interface
type MockLogger struct {
        mock.Mock
}

func (m *MockLogger) Debug(msg string, fields ...logger.Field) <span class="cov0" title="0">{
        m.Called(msg, fields)
}</span>

func (m *MockLogger) Info(msg string, fields ...logger.Field) <span class="cov0" title="0">{
        m.Called(msg, fields)
}</span>

func (m *MockLogger) Warn(msg string, fields ...logger.Field) <span class="cov0" title="0">{
        m.Called(msg, fields)
}</span>

func (m *MockLogger) Error(msg string, fields ...logger.Field) <span class="cov0" title="0">{
        m.Called(msg, fields)
}</span>

func (m *MockLogger) Fatal(msg string, fields ...logger.Field) <span class="cov0" title="0">{
        m.Called(msg, fields)
}</span>

// MockSpan is a mock implementation of the trace.Span interface
type MockSpan struct {
        mock.Mock
}

func (m *MockSpan) End(options ...trace.SpanEndOption) <span class="cov0" title="0">{
        m.Called(options)
}</span>

func (m *MockSpan) AddEvent(name string, options ...trace.EventOption) <span class="cov0" title="0">{
        m.Called(name, options)
}</span>

func (m *MockSpan) IsRecording() bool <span class="cov0" title="0">{
        args := m.Called()
        return args.Bool(0)
}</span>

func (m *MockSpan) RecordError(err error, options ...trace.EventOption) <span class="cov0" title="0">{
        m.Called(err, options)
}</span>

func (m *MockSpan) SpanContext() trace.SpanContext <span class="cov0" title="0">{
        args := m.Called()
        return args.Get(0).(trace.SpanContext)
}</span>

func (m *MockSpan) SetStatus(code codes.Code, description string) <span class="cov0" title="0">{
        m.Called(code, description)
}</span>

func (m *MockSpan) SetName(name string) <span class="cov0" title="0">{
        m.Called(name)
}</span>

func (m *MockSpan) SetAttributes(attrs ...attribute.KeyValue) <span class="cov0" title="0">{
        m.Called(attrs)
}</span>

func (m *MockSpan) TracerProvider() trace.TracerProvider <span class="cov0" title="0">{
        args := m.Called()
        return args.Get(0).(trace.TracerProvider)
}</span>

// MockTracer is a mock implementation of the trace.Tracer interface
type MockTracer struct {
        mock.Mock
}

func (m *MockTracer) Start(ctx context.Context, spanName string, opts ...trace.SpanStartOption) (context.Context, trace.Span) <span class="cov0" title="0">{
        args := m.Called(ctx, spanName, opts)
        return args.Get(0).(context.Context), args.Get(1).(trace.Span)
}</span>

// MockTracerProvider is a mock implementation of the trace.TracerProvider interface
type MockTracerProvider struct {
        mock.Mock
}

func (m *MockTracerProvider) Tracer(name string, opts ...trace.TracerOption) trace.Tracer <span class="cov0" title="0">{
        args := m.Called(name, opts)
        return args.Get(0).(trace.Tracer)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
