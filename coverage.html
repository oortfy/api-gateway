
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>middleware: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">api-gateway/internal/middleware/auth.go (79.3%)</option>
				
				<option value="file1">api-gateway/internal/middleware/cache.go (79.7%)</option>
				
				<option value="file2">api-gateway/internal/middleware/cors.go (100.0%)</option>
				
				<option value="file3">api-gateway/internal/middleware/header_transform.go (100.0%)</option>
				
				<option value="file4">api-gateway/internal/middleware/metrics.go (100.0%)</option>
				
				<option value="file5">api-gateway/internal/middleware/ratelimit.go (82.5%)</option>
				
				<option value="file6">api-gateway/internal/middleware/retry.go (85.5%)</option>
				
				<option value="file7">api-gateway/internal/middleware/tracing.go (51.3%)</option>
				
				<option value="file8">api-gateway/internal/middleware/url_rewrite.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package middleware

import (
        "net/http"

        "api-gateway/internal/auth"
        "api-gateway/internal/config"
        "api-gateway/pkg/logger"
)

// AuthMiddleware provides authentication middleware functionality
type AuthMiddleware struct {
        authService *auth.AuthService
        authConfig  *config.AuthConfig
        log         logger.Logger
}

// NewAuthMiddleware creates a new authentication middleware
func NewAuthMiddleware(authService *auth.AuthService, authConfig *config.AuthConfig, log logger.Logger) *AuthMiddleware <span class="cov8" title="1">{
        return &amp;AuthMiddleware{
                authService: authService,
                authConfig:  authConfig,
                log:         log,
        }
}</span>

// safeError is a helper function to safely write error responses
func safeError(w http.ResponseWriter, msg string, statusCode int) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "text/plain; charset=utf-8")
        w.Header().Set("X-Content-Type-Options", "nosniff")
        w.WriteHeader(statusCode)
        // We ignore any write errors as there's not much we can do about them
        w.Write([]byte(msg))
}</span>

// Authenticate checks if the request has valid authentication
func (m *AuthMiddleware) Authenticate(next http.Handler, route config.Route) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                // Skip authentication if not required for this route
                if !route.Middlewares.RequireAuth </span><span class="cov8" title="1">{
                        next.ServeHTTP(w, r)
                        return
                }</span>

                // Skip authentication for OPTIONS requests (CORS preflight)
                <span class="cov8" title="1">if r.Method == http.MethodOptions </span><span class="cov8" title="1">{
                        next.ServeHTTP(w, r)
                        return
                }</span>

                // Extract the API key from headers if present
                <span class="cov8" title="1">apiKey := r.Header.Get("x-api-key")
                if apiKey != "" </span><span class="cov0" title="0">{
                        // If API key is present, set it to the expected header name
                        r.Header.Set(m.authConfig.APIKeyHeader, apiKey)
                }</span>

                // Validate the token - passing empty slice for allowedRoles to skip role checking
                <span class="cov8" title="1">valid, err := m.authService.ValidateToken(r, []string{})
                if err != nil </span><span class="cov8" title="1">{
                        m.log.Debug("Authentication failed",
                                logger.String("path", r.URL.Path),
                                logger.String("method", r.Method),
                                logger.Error(err),
                        )

                        // Send appropriate error response using our safe error function
                        switch err </span>{
                        case auth.ErrNoToken:<span class="cov8" title="1">
                                safeError(w, "Authorization required", http.StatusUnauthorized)</span>
                        case auth.ErrInvalidToken, auth.ErrExpiredToken:<span class="cov8" title="1">
                                safeError(w, err.Error(), http.StatusUnauthorized)</span>
                        case auth.ErrForbidden:<span class="cov0" title="0">
                                safeError(w, "Forbidden: Insufficient permissions", http.StatusForbidden)</span>
                        default:<span class="cov0" title="0">
                                safeError(w, "Authentication failed", http.StatusUnauthorized)</span>
                        }
                        <span class="cov8" title="1">return</span>
                }

                <span class="cov8" title="1">if !valid </span><span class="cov0" title="0">{
                        m.log.Debug("Authentication invalid",
                                logger.String("path", r.URL.Path),
                                logger.String("method", r.Method),
                        )
                        safeError(w, "Authentication failed", http.StatusUnauthorized)
                        return
                }</span>

                // Authentication succeeded, continue to the next handler
                <span class="cov8" title="1">next.ServeHTTP(w, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package middleware

import (
        "bytes"
        "crypto/sha256"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "net/http"
        "strconv"
        "strings"
        "sync"
        "time"

        "api-gateway/internal/config"
        "api-gateway/pkg/logger"
)

// CacheEntry represents a cached HTTP response
type CacheEntry struct {
        StatusCode int
        Body       []byte
        Headers    http.Header
        Expiration time.Time
}

// CacheMiddleware provides HTTP response caching
type CacheMiddleware struct {
        cache     map[string]*CacheEntry
        mutex     sync.RWMutex
        config    *config.CacheConfig
        log       logger.Logger
        size      int
        evictList []string // List of cache keys ordered by access time
}

// NewCacheMiddleware creates a new cache middleware
func NewCacheMiddleware(config *config.CacheConfig, log logger.Logger) *CacheMiddleware <span class="cov8" title="1">{
        return &amp;CacheMiddleware{
                cache:     make(map[string]*CacheEntry),
                config:    config,
                log:       log,
                evictList: make([]string, 0),
        }
}</span>

// PurgeCache handles cache purge requests
func (c *CacheMiddleware) PurgeCache(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // Only allow POST method for purging
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov8" title="1">c.mutex.Lock()
        defer c.mutex.Unlock()

        // Get the path pattern to purge from query parameter
        pathPattern := r.URL.Query().Get("path")

        beforeCount := len(c.cache)
        if pathPattern != "" </span><span class="cov8" title="1">{
                // Purge specific path pattern
                for key := range c.cache </span><span class="cov8" title="1">{
                        if strings.Contains(key, pathPattern) </span><span class="cov8" title="1">{
                                delete(c.cache, key)
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                // Purge all cache if no path specified
                c.cache = make(map[string]*CacheEntry)
        }</span>
        <span class="cov8" title="1">afterCount := len(c.cache)
        purgedCount := beforeCount - afterCount

        c.log.Info("Cache purged",
                logger.String("path_pattern", pathPattern),
                logger.Int("purged_entries", purgedCount),
                logger.Int("remaining_entries", afterCount),
        )

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        response := map[string]interface{}{
                "success":           true,
                "purged_entries":    purgedCount,
                "remaining_entries": afterCount,
        }
        json.NewEncoder(w).Encode(response)</span>
}

// RegisterPurgeEndpoint registers the cache purge endpoint
func (c *CacheMiddleware) RegisterPurgeEndpoint(router http.Handler) http.Handler <span class="cov8" title="1">{
        if !c.config.Enabled || c.config.PurgeEndpoint == "" </span><span class="cov0" title="0">{
                return router
        }</span>

        <span class="cov8" title="1">handler := http.NewServeMux()

        // Copy all requests to the original router
        handler.Handle("/", router)

        // Add the purge endpoint
        handler.HandleFunc(c.config.PurgeEndpoint, c.PurgeCache)

        c.log.Info("Registered cache purge endpoint",
                logger.String("endpoint", c.config.PurgeEndpoint),
        )

        return handler</span>
}

// Cache middleware caches responses for GET requests
func (c *CacheMiddleware) Cache(next http.Handler, route config.Route) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                // Skip caching if not enabled for this route or if it's not a GET request
                if !c.shouldCache(r, route) </span><span class="cov8" title="1">{
                        next.ServeHTTP(w, r)
                        return
                }</span>

                // Generate cache key from request
                <span class="cov8" title="1">key := c.generateCacheKey(r)

                // Try to get from cache
                entry := c.getFromCache(key)
                if entry != nil </span><span class="cov8" title="1">{
                        c.log.Debug("Cache hit",
                                logger.String("path", r.URL.Path),
                                logger.String("method", r.Method),
                                logger.String("key", key),
                        )
                        c.serveFromCache(w, entry)
                        return
                }</span>

                // If not in cache, capture the response
                <span class="cov8" title="1">c.log.Debug("Cache miss",
                        logger.String("path", r.URL.Path),
                        logger.String("method", r.Method),
                        logger.String("key", key),
                )

                // Create a buffer to store the response
                buf := &amp;bytes.Buffer{}

                // Create a custom response writer to capture the response
                crw := &amp;cachingResponseWriter{
                        ResponseWriter: w,
                        buffer:         buf,
                        statusCode:     http.StatusOK,
                        headers:        make(http.Header),
                }

                // Process the request
                next.ServeHTTP(crw, r)

                // Don't cache error responses
                if crw.statusCode &gt;= 400 </span><span class="cov0" title="0">{
                        return
                }</span>

                // Determine TTL for cache entry
                <span class="cov8" title="1">ttl := c.getTTL(r, crw.headers, route)
                if ttl &lt;= 0 </span><span class="cov0" title="0">{
                        return
                }</span>

                // Store in cache
                <span class="cov8" title="1">c.storeInCache(key, crw.statusCode, buf.Bytes(), crw.headers, ttl)</span>
        })
}

// shouldCache determines if a request should be cached
func (c *CacheMiddleware) shouldCache(r *http.Request, route config.Route) bool <span class="cov8" title="1">{
        // Check if cache is globally disabled
        if !c.config.Enabled </span><span class="cov0" title="0">{
                return false
        }</span>

        // Only cache enabled routes
        <span class="cov8" title="1">if route.Middlewares.Cache == nil || !route.Middlewares.Cache.Enabled </span><span class="cov0" title="0">{
                return false
        }</span>

        // Only cache GET requests
        <span class="cov8" title="1">if r.Method != http.MethodGet </span><span class="cov8" title="1">{
                return false
        }</span>

        // Don't cache if Cache-Control: no-cache or no-store
        <span class="cov8" title="1">cacheControl := r.Header.Get("Cache-Control")
        if strings.Contains(cacheControl, "no-cache") || strings.Contains(cacheControl, "no-store") </span><span class="cov8" title="1">{
                return false
        }</span>

        // Don't cache authenticated requests unless specified
        <span class="cov8" title="1">if !route.Middlewares.Cache.CacheAuthenticated &amp;&amp; (r.Header.Get("Authorization") != "" || r.Header.Get("x-api-key") != "") </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}

// generateCacheKey creates a unique key for the cache entry
func (c *CacheMiddleware) generateCacheKey(r *http.Request) string <span class="cov8" title="1">{
        // Basic key components
        key := r.Method + ":" + r.URL.Path + ":" + r.URL.RawQuery

        // Add host if vhost-based routing is used
        if c.config.IncludeHost </span><span class="cov0" title="0">{
                key = r.Host + ":" + key
        }</span>

        // Add certain headers to the key if configured
        <span class="cov8" title="1">for _, header := range c.config.VaryHeaders </span><span class="cov8" title="1">{
                if value := r.Header.Get(header); value != "" </span><span class="cov8" title="1">{
                        key += ":" + header + "=" + value
                }</span>
        }

        // Hash the key to keep it a reasonable length
        <span class="cov8" title="1">hasher := sha256.New()
        hasher.Write([]byte(key))
        return hex.EncodeToString(hasher.Sum(nil))</span>
}

// getFromCache retrieves a value from the cache
func (c *CacheMiddleware) getFromCache(key string) *CacheEntry <span class="cov8" title="1">{
        c.mutex.RLock()
        defer c.mutex.RUnlock()

        entry, exists := c.cache[key]
        if !exists </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Check if entry has expired
        <span class="cov8" title="1">if time.Now().After(entry.Expiration) </span><span class="cov0" title="0">{
                // Expired entry, remove it
                go c.removeFromCache(key)
                return nil
        }</span>

        <span class="cov8" title="1">return entry</span>
}

// removeFromCache removes a value from the cache
func (c *CacheMiddleware) removeFromCache(key string) <span class="cov0" title="0">{
        c.mutex.Lock()
        defer c.mutex.Unlock()

        delete(c.cache, key)
}</span>

// storeInCache stores a value in the cache
func (c *CacheMiddleware) storeInCache(key string, statusCode int, body []byte, headers http.Header, ttl time.Duration) <span class="cov8" title="1">{
        c.mutex.Lock()
        defer c.mutex.Unlock()

        // Check if we need to evict entries
        if c.config.MaxSize &gt; 0 &amp;&amp; len(c.cache) &gt;= c.config.MaxSize </span><span class="cov0" title="0">{
                // Evict oldest entries
                for _, oldKey := range c.evictList[:len(c.evictList)/2] </span><span class="cov0" title="0">{
                        delete(c.cache, oldKey)
                }</span>
                <span class="cov0" title="0">c.evictList = c.evictList[len(c.evictList)/2:]
                c.log.Info("Cache eviction performed",
                        logger.Int("evicted_count", len(c.evictList)/2),
                        logger.Int("remaining_entries", len(c.cache)),
                )</span>
        }

        // Create a copy of the headers
        <span class="cov8" title="1">headersCopy := make(http.Header)
        for k, v := range headers </span><span class="cov8" title="1">{
                headersCopy[k] = v
        }</span>

        // Add cache-related headers
        <span class="cov8" title="1">headersCopy.Set("Cache-Control", fmt.Sprintf("public, max-age=%d", int(ttl.Seconds())))
        headersCopy.Set("Age", "0")
        headersCopy.Set("X-Cache-TTL", fmt.Sprintf("%d", int(ttl.Seconds())))

        // Create a cache entry
        entry := &amp;CacheEntry{
                StatusCode: statusCode,
                Body:       body,
                Headers:    headersCopy,
                Expiration: time.Now().Add(ttl),
        }

        // Store in cache and update eviction list
        c.cache[key] = entry
        c.evictList = append(c.evictList, key)

        // Set up automatic expiration
        time.AfterFunc(ttl, func() </span><span class="cov0" title="0">{
                c.removeFromCache(key)
        }</span>)
}

// serveFromCache serves a cached response
func (c *CacheMiddleware) serveFromCache(w http.ResponseWriter, entry *CacheEntry) <span class="cov8" title="1">{
        // Calculate age of the cache entry
        ttlStr := entry.Headers.Get("X-Cache-TTL")
        ttl, _ := strconv.Atoi(ttlStr)
        age := int(time.Since(entry.Expiration.Add(-time.Duration(ttl) * time.Second)).Seconds())

        // Copy headers from cached response
        for k, v := range entry.Headers </span><span class="cov8" title="1">{
                for _, val := range v </span><span class="cov8" title="1">{
                        w.Header().Add(k, val)
                }</span>
        }

        // Update cache-related headers
        <span class="cov8" title="1">w.Header().Set("Age", strconv.Itoa(age))
        w.Header().Set("X-Cache", "HIT")

        // Set status code and write body
        w.WriteHeader(entry.StatusCode)
        w.Write(entry.Body)</span>
}

// getTTL determines the TTL for a cache entry
func (c *CacheMiddleware) getTTL(r *http.Request, headers http.Header, route config.Route) time.Duration <span class="cov8" title="1">{
        // Default TTL from route config
        ttl := time.Duration(route.Middlewares.Cache.TTL) * time.Second

        // Check for Cache-Control: max-age
        cacheControl := headers.Get("Cache-Control")
        if strings.Contains(cacheControl, "max-age=") </span><span class="cov0" title="0">{
                parts := strings.Split(cacheControl, "max-age=")
                if len(parts) &gt; 1 </span><span class="cov0" title="0">{
                        maxAge := strings.Split(parts[1], ",")[0]
                        if seconds, err := strconv.Atoi(maxAge); err == nil </span><span class="cov0" title="0">{
                                return time.Duration(seconds) * time.Second
                        }</span>
                }
        }

        // Check for Expires header
        <span class="cov8" title="1">expires := headers.Get("Expires")
        if expires != "" </span><span class="cov0" title="0">{
                if expTime, err := time.Parse(time.RFC1123, expires); err == nil </span><span class="cov0" title="0">{
                        ttl = expTime.Sub(time.Now())
                }</span>
        }

        // If TTL is negative or zero, don't cache
        <span class="cov8" title="1">if ttl &lt;= 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        // Apply maximum TTL if configured
        <span class="cov8" title="1">if c.config.MaxTTL &gt; 0 &amp;&amp; ttl &gt; time.Duration(c.config.MaxTTL)*time.Second </span><span class="cov0" title="0">{
                ttl = time.Duration(c.config.MaxTTL) * time.Second
        }</span>

        <span class="cov8" title="1">return ttl</span>
}

// cachingResponseWriter captures the response for caching
type cachingResponseWriter struct {
        http.ResponseWriter
        buffer     *bytes.Buffer
        statusCode int
        headers    http.Header
}

// WriteHeader captures the status code
func (crw *cachingResponseWriter) WriteHeader(statusCode int) <span class="cov8" title="1">{
        crw.statusCode = statusCode
        crw.ResponseWriter.WriteHeader(statusCode)
}</span>

// Write captures the response body
func (crw *cachingResponseWriter) Write(b []byte) (int, error) <span class="cov8" title="1">{
        crw.buffer.Write(b)
        return crw.ResponseWriter.Write(b)
}</span>

// Header captures the response headers
func (crw *cachingResponseWriter) Header() http.Header <span class="cov8" title="1">{
        h := crw.ResponseWriter.Header()

        // Copy headers to our internal storage
        for k, v := range h </span><span class="cov8" title="1">{
                crw.headers[k] = v
        }</span>

        <span class="cov8" title="1">return h</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package middleware

import (
        "net/http"
        "strconv"
        "strings"

        "api-gateway/internal/config"
        "api-gateway/pkg/logger"
)

// CORSMiddleware provides CORS functionality
type CORSMiddleware struct {
        config *config.CORSConfig
        log    logger.Logger
}

// NewCORSMiddleware creates a new CORS middleware
func NewCORSMiddleware(config *config.CORSConfig, log logger.Logger) *CORSMiddleware <span class="cov8" title="1">{
        return &amp;CORSMiddleware{
                config: config,
                log:    log,
        }
}</span>

// CORS middleware handles Cross-Origin Resource Sharing
func (c *CORSMiddleware) CORS(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                // If CORS is disabled, just pass through
                if !c.config.Enabled </span><span class="cov8" title="1">{
                        next.ServeHTTP(w, r)
                        return
                }</span>

                <span class="cov8" title="1">origin := r.Header.Get("Origin")
                if origin == "" </span><span class="cov8" title="1">{
                        // Not a CORS request, continue
                        next.ServeHTTP(w, r)
                        return
                }</span>

                // Check if the origin is allowed
                <span class="cov8" title="1">if !c.isOriginAllowed(origin) </span><span class="cov8" title="1">{
                        // Origin not allowed, continue without CORS headers
                        next.ServeHTTP(w, r)
                        return
                }</span>

                // Create a wrapper for the response writer to capture and modify headers
                <span class="cov8" title="1">wrapper := &amp;corsResponseWriter{
                        ResponseWriter: w,
                        config:         c.config,
                        origin:         origin,
                        log:            c.log,
                }

                // Handle preflight requests
                if r.Method == http.MethodOptions </span><span class="cov8" title="1">{
                        requestMethod := r.Header.Get("Access-Control-Request-Method")
                        if requestMethod != "" </span><span class="cov8" title="1">{
                                // Process preflight request
                                wrapper.handlePreflight(requestMethod)
                                return
                        }</span>
                }

                // Continue with the request using our wrapper
                <span class="cov8" title="1">next.ServeHTTP(wrapper, r)</span>
        })
}

// corsResponseWriter wraps http.ResponseWriter to handle CORS headers
type corsResponseWriter struct {
        http.ResponseWriter
        config *config.CORSConfig
        origin string
        log    logger.Logger
}

// handlePreflight processes OPTIONS preflight requests
func (w *corsResponseWriter) handlePreflight(requestMethod string) <span class="cov8" title="1">{
        // Set CORS headers for preflight
        w.setCORSHeaders()

        // Set method-specific preflight headers
        w.Header().Set("Access-Control-Allow-Methods", strings.Join(w.config.AllowedMethods, ","))
        w.Header().Set("Access-Control-Allow-Headers", strings.Join(w.config.AllowedHeaders, ","))
        w.Header().Set("Access-Control-Max-Age", strconv.Itoa(w.config.MaxAge))

        w.log.Info("CORS preflight request processed",
                logger.String("origin", w.origin),
                logger.String("method", requestMethod),
        )

        // Preflight request completed
        w.WriteHeader(http.StatusOK)
}</span>

// WriteHeader overrides the original WriteHeader to ensure CORS headers are set first
func (w *corsResponseWriter) WriteHeader(statusCode int) <span class="cov8" title="1">{
        w.setCORSHeaders()
        w.ResponseWriter.WriteHeader(statusCode)
}</span>

// Write overrides the original Write to ensure CORS headers are set
func (w *corsResponseWriter) Write(b []byte) (int, error) <span class="cov8" title="1">{
        w.setCORSHeaders()
        return w.ResponseWriter.Write(b)
}</span>

// setCORSHeaders sets the CORS headers if they aren't already set
func (w *corsResponseWriter) setCORSHeaders() <span class="cov8" title="1">{
        // If the Access-Control-Allow-Origin header is already set, don't override it
        if w.Header().Get("Access-Control-Allow-Origin") != "" </span><span class="cov8" title="1">{
                return
        }</span>

        // Set allowed origin
        <span class="cov8" title="1">useWildcard := w.config.AllowAllOrigins ||
                (len(w.config.AllowedOrigins) == 1 &amp;&amp; w.config.AllowedOrigins[0] == "*" &amp;&amp;
                        !w.config.AllowCredentials)

        if useWildcard </span><span class="cov8" title="1">{
                w.Header().Set("Access-Control-Allow-Origin", "*")
        }</span> else<span class="cov8" title="1"> {
                w.Header().Set("Access-Control-Allow-Origin", w.origin)
                w.Header().Set("Vary", "Origin")
        }</span>

        // Set other CORS headers
        <span class="cov8" title="1">if w.config.AllowCredentials </span><span class="cov8" title="1">{
                w.Header().Set("Access-Control-Allow-Credentials", "true")
        }</span>

        <span class="cov8" title="1">if len(w.config.ExposedHeaders) &gt; 0 </span><span class="cov8" title="1">{
                w.Header().Set("Access-Control-Expose-Headers", strings.Join(w.config.ExposedHeaders, ","))
        }</span>
}

// isOriginAllowed checks if the origin is allowed
func (c *CORSMiddleware) isOriginAllowed(origin string) bool <span class="cov8" title="1">{
        if c.config.AllowAllOrigins </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">for _, allowedOrigin := range c.config.AllowedOrigins </span><span class="cov8" title="1">{
                if allowedOrigin == "*" </span><span class="cov8" title="1">{
                        return true
                }</span>
                <span class="cov8" title="1">if allowedOrigin == origin </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}</pre>
		
		<pre class="file" id="file3" style="display: none">package middleware

import (
        "net/http"

        "api-gateway/internal/config"
        "api-gateway/pkg/logger"
)

// HeaderTransformer handles transformation of HTTP headers
type HeaderTransformer struct {
        log logger.Logger
}

// NewHeaderTransformer creates a new header transformation middleware
func NewHeaderTransformer(log logger.Logger) *HeaderTransformer <span class="cov8" title="1">{
        return &amp;HeaderTransformer{
                log: log,
        }
}</span>

// Transform applies header transformations based on configuration
func (h *HeaderTransformer) Transform(next http.Handler, transform *config.HeaderTransform) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                if transform == nil </span><span class="cov8" title="1">{
                        next.ServeHTTP(w, r)
                        return
                }</span>

                // Apply request header transformations
                <span class="cov8" title="1">for key, value := range transform.Request </span><span class="cov8" title="1">{
                        r.Header.Set(key, value)
                }</span>

                // Create a custom response writer to handle response header transformations
                <span class="cov8" title="1">tw := &amp;transformResponseWriter{
                        ResponseWriter: w,
                        transform:      transform,
                        log:            h.log,
                }

                // Continue to next handler with our custom response writer
                next.ServeHTTP(tw, r)</span>
        })
}

// transformResponseWriter is a wrapper for http.ResponseWriter that
// applies header transformations to responses
type transformResponseWriter struct {
        http.ResponseWriter
        transform   *config.HeaderTransform
        log         logger.Logger
        wroteHeader bool
}

// WriteHeader overrides the original WriteHeader to apply header transformations
func (tw *transformResponseWriter) WriteHeader(statusCode int) <span class="cov8" title="1">{
        if tw.wroteHeader </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">tw.wroteHeader = true

        // Apply response header transformations
        for key, value := range tw.transform.Response </span><span class="cov8" title="1">{
                // Empty value means remove the header
                if value == "" </span><span class="cov8" title="1">{
                        tw.ResponseWriter.Header().Del(key)
                }</span> else<span class="cov8" title="1"> {
                        tw.ResponseWriter.Header().Set(key, value)
                }</span>
        }

        // Remove headers if specified
        <span class="cov8" title="1">for _, header := range tw.transform.Remove </span><span class="cov8" title="1">{
                tw.ResponseWriter.Header().Del(header)
        }</span>

        <span class="cov8" title="1">tw.ResponseWriter.WriteHeader(statusCode)</span>
}

// Write overrides the original Write method to ensure headers are written
func (tw *transformResponseWriter) Write(b []byte) (int, error) <span class="cov8" title="1">{
        if !tw.wroteHeader </span><span class="cov8" title="1">{
                tw.WriteHeader(http.StatusOK)
        }</span>
        <span class="cov8" title="1">return tw.ResponseWriter.Write(b)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package middleware

import (
        "net/http"
        "strconv"
        "time"

        "api-gateway/internal/config"
        "api-gateway/pkg/logger"

        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promhttp"
)

var (
        // RequestDuration tracks request duration
        requestDuration = prometheus.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "gateway_request_duration_seconds",
                        Help:    "Request duration in seconds",
                        Buckets: prometheus.DefBuckets,
                },
                []string{"method", "path", "status"},
        )

        // RequestsTotal tracks the total number of requests
        requestsTotal = prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "gateway_requests_total",
                        Help: "Total number of requests",
                },
                []string{"method", "path", "status"},
        )

        // CircuitBreakerStatus tracks circuit breaker status
        circuitBreakerStatus = prometheus.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "gateway_circuit_breaker_status",
                        Help: "Circuit breaker status (0=closed, 1=open, 2=half-open)",
                },
                []string{"path"},
        )

        // CacheHits tracks cache hits
        cacheHits = prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "gateway_cache_hits_total",
                        Help: "Total number of cache hits",
                },
                []string{"path"},
        )

        // CacheMisses tracks cache misses
        cacheMisses = prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "gateway_cache_misses_total",
                        Help: "Total number of cache misses",
                },
                []string{"path"},
        )

        // RateLimitRejections tracks rate limit rejections
        rateLimitRejections = prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "gateway_rate_limit_rejections_total",
                        Help: "Total number of requests rejected due to rate limits",
                },
                []string{"path"},
        )
)

func init() <span class="cov8" title="1">{
        // Register metrics with Prometheus
        prometheus.MustRegister(requestDuration)
        prometheus.MustRegister(requestsTotal)
        prometheus.MustRegister(circuitBreakerStatus)
        prometheus.MustRegister(cacheHits)
        prometheus.MustRegister(cacheMisses)
        prometheus.MustRegister(rateLimitRejections)
}</span>

// MetricsMiddleware provides metrics collection and endpoints
type MetricsMiddleware struct {
        config *config.MetricsConfig
        log    logger.Logger
}

// NewMetricsMiddleware creates a new metrics middleware
func NewMetricsMiddleware(config *config.MetricsConfig, log logger.Logger) *MetricsMiddleware <span class="cov8" title="1">{
        return &amp;MetricsMiddleware{
                config: config,
                log:    log,
        }
}</span>

// RegisterMetricsEndpoint registers the metrics endpoint
func (m *MetricsMiddleware) RegisterMetricsEndpoint(router http.Handler) http.Handler <span class="cov8" title="1">{
        if !m.config.Enabled </span><span class="cov8" title="1">{
                return router
        }</span>

        // Create a handler for the metrics endpoint
        <span class="cov8" title="1">handler := http.NewServeMux()

        // Copy all requests to the original router
        handler.Handle("/", router)

        // Add the metrics endpoint
        handler.Handle(m.config.Endpoint, promhttp.Handler())

        m.log.Info("Registered metrics endpoint",
                logger.String("endpoint", m.config.Endpoint),
        )

        return handler</span>
}

// Metrics middleware collects metrics for each request
func (m *MetricsMiddleware) Metrics(next http.Handler) http.Handler <span class="cov8" title="1">{
        if !m.config.Enabled </span><span class="cov8" title="1">{
                return next
        }</span>

        <span class="cov8" title="1">return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                start := time.Now()

                // Create a response writer that captures the status code
                recorder := &amp;responseRecorder{
                        ResponseWriter: w,
                        statusCode:     http.StatusOK,
                }

                // Process the request
                next.ServeHTTP(recorder, r)

                // Record metrics
                duration := time.Since(start).Seconds()
                path := r.URL.Path
                method := r.Method
                status := strconv.Itoa(recorder.statusCode)

                requestDuration.WithLabelValues(method, path, status).Observe(duration)
                requestsTotal.WithLabelValues(method, path, status).Inc()
        }</span>)
}

// IncrementCacheHit increments the cache hit counter
func (m *MetricsMiddleware) IncrementCacheHit(path string) <span class="cov8" title="1">{
        if m.config.Enabled </span><span class="cov8" title="1">{
                cacheHits.WithLabelValues(path).Inc()
        }</span>
}

// IncrementCacheMiss increments the cache miss counter
func (m *MetricsMiddleware) IncrementCacheMiss(path string) <span class="cov8" title="1">{
        if m.config.Enabled </span><span class="cov8" title="1">{
                cacheMisses.WithLabelValues(path).Inc()
        }</span>
}

// IncrementRateLimit increments the rate limit counter
func (m *MetricsMiddleware) IncrementRateLimit(path string) <span class="cov8" title="1">{
        if m.config.Enabled </span><span class="cov8" title="1">{
                rateLimitRejections.WithLabelValues(path).Inc()
        }</span>
}

// SetCircuitBreakerStatus sets the circuit breaker status
func (m *MetricsMiddleware) SetCircuitBreakerStatus(path string, status float64) <span class="cov8" title="1">{
        if m.config.Enabled </span><span class="cov8" title="1">{
                circuitBreakerStatus.WithLabelValues(path).Set(status)
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package middleware

import (
        "fmt"
        "net"
        "net/http"
        "strings"
        "sync"
        "time"

        "api-gateway/internal/config"
        "api-gateway/pkg/logger"
)

// RateLimiter represents a rate limiting middleware
type RateLimiter struct {
        limits       map[string]config.RateLimitConfig
        buckets      map[string]map[string]*tokenBucket
        bucketsMutex sync.RWMutex
        log          logger.Logger
}

// tokenBucket implements the token bucket algorithm for rate limiting
type tokenBucket struct {
        tokens         float64
        maxTokens      float64
        refillRate     float64
        lastRefillTime time.Time
        mutex          sync.Mutex
}

// NewRateLimiter creates a new rate limiting middleware
func NewRateLimiter(log logger.Logger) *RateLimiter <span class="cov8" title="1">{
        return &amp;RateLimiter{
                limits:  make(map[string]config.RateLimitConfig),
                buckets: make(map[string]map[string]*tokenBucket),
                log:     log,
        }
}</span>

// AddLimit adds a rate limit for a specific path
func (rl *RateLimiter) AddLimit(path string, limit config.RateLimitConfig) <span class="cov8" title="1">{
        rl.limits[path] = limit
        rl.buckets[path] = make(map[string]*tokenBucket)
        rl.log.Info("Rate limit added",
                logger.String("path", path),
                logger.Int("requests", limit.Requests),
                logger.String("period", limit.Period))
}</span>

// getBucket gets or creates a token bucket for a client
func (rl *RateLimiter) getBucket(path, clientID string) *tokenBucket <span class="cov8" title="1">{
        rl.bucketsMutex.RLock()
        pathBuckets, pathExists := rl.buckets[path]
        if !pathExists </span><span class="cov0" title="0">{
                rl.bucketsMutex.RUnlock()
                return nil // Path not configured for rate limiting
        }</span>

        <span class="cov8" title="1">bucket, clientExists := pathBuckets[clientID]
        rl.bucketsMutex.RUnlock()

        if clientExists </span><span class="cov8" title="1">{
                return bucket
        }</span>

        // Create a new bucket if it doesn't exist
        <span class="cov8" title="1">rl.bucketsMutex.Lock()
        defer rl.bucketsMutex.Unlock()

        // Check again to avoid race conditions
        if pathBuckets, pathExists = rl.buckets[path]; !pathExists </span><span class="cov0" title="0">{
                return nil // Path not configured for rate limiting
        }</span>

        <span class="cov8" title="1">if bucket, clientExists = pathBuckets[clientID]; clientExists </span><span class="cov0" title="0">{
                return bucket
        }</span>

        <span class="cov8" title="1">limit, exists := rl.limits[path]
        if !exists </span><span class="cov0" title="0">{
                // If no specific limit is set for this path, create a default bucket
                // that doesn't actually rate limit (high limit)
                bucket = &amp;tokenBucket{
                        tokens:         1000,
                        maxTokens:      1000,
                        refillRate:     1000,
                        lastRefillTime: time.Now(),
                }
        }</span> else<span class="cov8" title="1"> {
                // Calculate tokens per second based on the limit
                var tokensPerSecond float64
                switch limit.Period </span>{
                case "second":<span class="cov0" title="0">
                        tokensPerSecond = float64(limit.Requests)</span>
                case "minute":<span class="cov8" title="1">
                        tokensPerSecond = float64(limit.Requests) / 60</span>
                case "hour":<span class="cov0" title="0">
                        tokensPerSecond = float64(limit.Requests) / 3600</span>
                case "day":<span class="cov0" title="0">
                        tokensPerSecond = float64(limit.Requests) / 86400</span>
                default:<span class="cov0" title="0">
                        tokensPerSecond = float64(limit.Requests) / 60</span> // Default to minute
                }

                <span class="cov8" title="1">bucket = &amp;tokenBucket{
                        tokens:         float64(limit.Requests),
                        maxTokens:      float64(limit.Requests),
                        refillRate:     tokensPerSecond,
                        lastRefillTime: time.Now(),
                }

                rl.log.Debug("New rate limit bucket created",
                        logger.String("path", path),
                        logger.String("client", clientID),
                        logger.Int("max_tokens", int(limit.Requests)),
                        logger.String("refill_rate", fmt.Sprintf("%.4f tokens/sec", tokensPerSecond)))</span>
        }

        <span class="cov8" title="1">rl.buckets[path][clientID] = bucket
        return bucket</span>
}

// getClientIP extracts the client IP from the request, handling common proxy headers
func (rl *RateLimiter) getClientIP(r *http.Request) string <span class="cov8" title="1">{
        // Check for X-Forwarded-For header (common in reverse proxies)
        if xff := r.Header.Get("X-Forwarded-For"); xff != "" </span><span class="cov8" title="1">{
                ips := strings.Split(xff, ",")
                // The leftmost IP is the original client
                if len(ips) &gt; 0 </span><span class="cov8" title="1">{
                        clientIP := strings.TrimSpace(ips[0])
                        return clientIP
                }</span>
        }

        // Check for X-Real-IP header (used by some proxies)
        <span class="cov8" title="1">if xrip := r.Header.Get("X-Real-IP"); xrip != "" </span><span class="cov8" title="1">{
                return xrip
        }</span>

        // Extract IP from RemoteAddr
        <span class="cov8" title="1">ip, _, err := net.SplitHostPort(r.RemoteAddr)
        if err != nil </span><span class="cov0" title="0">{
                // If we can't split, use the whole RemoteAddr
                ip = r.RemoteAddr
        }</span>

        <span class="cov8" title="1">return ip</span>
}

// RateLimit middleware applies rate limiting to requests
func (rl *RateLimiter) RateLimit(next http.Handler, route config.Route) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                // Skip rate limiting if not configured for this route
                if route.Middlewares.RateLimit == nil || route.Middlewares.RateLimit.Requests == 0 </span><span class="cov8" title="1">{
                        next.ServeHTTP(w, r)
                        return
                }</span>

                // Get a unique identifier for this client
                // In addition to IP, we can use API key or auth info if available
                <span class="cov8" title="1">clientID := rl.getClientIP(r)

                // Add auth information if available for per-user rate limiting
                if apiKey := r.Header.Get("X-API-Key"); apiKey != "" </span><span class="cov8" title="1">{
                        clientID = apiKey // Use API key as identifier if present
                }</span> else<span class="cov8" title="1"> if authHeader := r.Header.Get("Authorization"); authHeader != "" </span><span class="cov0" title="0">{
                        clientID = authHeader // Use auth token as identifier
                }</span>

                <span class="cov8" title="1">pathKey := route.Path
                rl.log.Debug("Rate limit check",
                        logger.String("path", r.URL.Path),
                        logger.String("pathKey", pathKey),
                        logger.String("clientID", clientID))

                // Get the bucket for this client
                bucket := rl.getBucket(pathKey, clientID)
                if bucket == nil </span><span class="cov0" title="0">{
                        rl.log.Warn("No rate limit bucket found for path",
                                logger.String("path", pathKey))
                        next.ServeHTTP(w, r)
                        return
                }</span>

                // Try to consume a token
                <span class="cov8" title="1">if allowed := rl.tryConsume(bucket); !allowed </span><span class="cov8" title="1">{
                        rl.log.Info("Rate limit exceeded",
                                logger.String("path", r.URL.Path),
                                logger.String("method", r.Method),
                                logger.String("client", clientID),
                        )

                        w.Header().Set("Retry-After", "60") // Suggest retry after period
                        w.Header().Set("X-RateLimit-Limit", "2")
                        w.Header().Set("X-RateLimit-Remaining", "0")
                        http.Error(w, "Rate limit exceeded. Try again later.", http.StatusTooManyRequests)
                        return
                }</span>

                // Continue to the next handler
                <span class="cov8" title="1">next.ServeHTTP(w, r)</span>
        })
}

// tryConsume attempts to consume a token from the bucket
func (rl *RateLimiter) tryConsume(bucket *tokenBucket) bool <span class="cov8" title="1">{
        bucket.mutex.Lock()
        defer bucket.mutex.Unlock()

        now := time.Now()
        elapsed := now.Sub(bucket.lastRefillTime).Seconds()

        // Refill the bucket based on time elapsed
        bucket.tokens = bucket.tokens + (elapsed * bucket.refillRate)
        if bucket.tokens &gt; bucket.maxTokens </span><span class="cov8" title="1">{
                bucket.tokens = bucket.maxTokens
        }</span>

        <span class="cov8" title="1">bucket.lastRefillTime = now

        // Check if we can consume a token
        if bucket.tokens &lt; 1 </span><span class="cov8" title="1">{
                return false
        }</span>

        // Consume a token
        <span class="cov8" title="1">bucket.tokens--
        return true</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package middleware

import (
        "bytes"
        "context"
        "io"
        "net/http"
        "strings"
        "time"

        "api-gateway/internal/config"
        "api-gateway/pkg/logger"
)

// RetryMiddleware provides retry functionality for failed requests
type RetryMiddleware struct {
        log logger.Logger
}

// NewRetryMiddleware creates a new retry middleware
func NewRetryMiddleware(log logger.Logger) *RetryMiddleware <span class="cov8" title="1">{
        return &amp;RetryMiddleware{
                log: log,
        }
}</span>

// Retry wraps a handler with retry logic
func (r *RetryMiddleware) Retry(next http.Handler, policy *config.RetryPolicy) http.Handler <span class="cov8" title="1">{
        if policy == nil || !policy.Enabled || policy.Attempts &lt;= 1 </span><span class="cov8" title="1">{
                return next
        }</span>

        <span class="cov8" title="1">return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) </span><span class="cov8" title="1">{
                // Create a response recorder to capture the response
                recorder := &amp;responseRecorder{
                        ResponseWriter: w,
                        statusCode:     http.StatusOK,
                        body:           new(bytes.Buffer),
                }

                var err error
                // Copy the request body for potential retries
                var bodyBytes []byte
                if req.Body != nil </span><span class="cov8" title="1">{
                        bodyBytes, err = io.ReadAll(req.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                r.log.Error("Failed to read request body",
                                        logger.String("path", req.URL.Path),
                                        logger.Error(err),
                                )
                                http.Error(w, "Internal Server Error", http.StatusInternalServerError)
                                return
                        }</span>
                        <span class="cov8" title="1">req.Body.Close()</span>
                }

                // Try the request multiple times if needed
                <span class="cov8" title="1">attempts := policy.Attempts
                perTryTimeout := time.Duration(policy.PerTryTimeout) * time.Second

                for attempt := 1; attempt &lt;= attempts; attempt++ </span><span class="cov8" title="1">{
                        // Reset the request body if needed
                        if bodyBytes != nil </span><span class="cov8" title="1">{
                                req.Body = io.NopCloser(bytes.NewReader(bodyBytes))
                        }</span>

                        // Track the attempt in request headers for debugging
                        <span class="cov8" title="1">req.Header.Set("X-Retry-Attempt",
                                strings.Join([]string{
                                        string('0' + rune(attempt)),
                                        string('0' + rune(attempts))},
                                        "/"))

                        // Create a context with timeout for this attempt
                        ctx := req.Context()
                        if perTryTimeout &gt; 0 </span><span class="cov0" title="0">{
                                var cancel context.CancelFunc
                                ctx, cancel = context.WithTimeout(req.Context(), perTryTimeout)
                                defer cancel()
                        }</span>

                        // Serve the request with the new context
                        <span class="cov8" title="1">recorder.Reset()
                        next.ServeHTTP(recorder, req.WithContext(ctx))

                        // Check if we should retry
                        shouldRetry := r.shouldRetry(policy.RetryOn, recorder.statusCode, err)
                        if !shouldRetry || attempt == attempts </span><span class="cov8" title="1">{
                                // On the last attempt or if we shouldn't retry, copy the response to the original writer
                                for key, values := range recorder.Header() </span><span class="cov0" title="0">{
                                        for _, value := range values </span><span class="cov0" title="0">{
                                                w.Header().Add(key, value)
                                        }</span>
                                }
                                <span class="cov8" title="1">w.WriteHeader(recorder.statusCode)
                                if recorder.body != nil </span><span class="cov8" title="1">{
                                        w.Write(recorder.body.Bytes())
                                }</span>
                                <span class="cov8" title="1">return</span>
                        }

                        <span class="cov8" title="1">r.log.Debug("Retrying request",
                                logger.String("path", req.URL.Path),
                                logger.Int("attempt", attempt),
                                logger.Int("max_attempts", attempts),
                                logger.Int("status_code", recorder.statusCode),
                        )

                        // Slight delay before retry using exponential backoff
                        backoff := time.Duration(attempt*attempt*50) * time.Millisecond
                        time.Sleep(backoff)</span>
                }
        })
}

// shouldRetry determines if a request should be retried based on the retry policy
func (r *RetryMiddleware) shouldRetry(retryOn []string, statusCode int, err error) bool <span class="cov8" title="1">{
        // If there was a network error, retry
        if err != nil </span><span class="cov8" title="1">{
                return contains(retryOn, "connection_error") || contains(retryOn, "network_error")
        }</span>

        // Check status code based retry conditions
        <span class="cov8" title="1">if statusCode &gt;= 500 &amp;&amp; contains(retryOn, "server_error") </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">if statusCode == http.StatusTooManyRequests &amp;&amp; contains(retryOn, "rate_limited") </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">if statusCode == http.StatusGatewayTimeout &amp;&amp; contains(retryOn, "gateway_timeout") </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">return false</span>
}

// contains checks if a string slice contains a specific value
func contains(slice []string, item string) bool <span class="cov8" title="1">{
        for _, s := range slice </span><span class="cov8" title="1">{
                if s == item </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// responseRecorder is a wrapper around http.ResponseWriter that records the response
type responseRecorder struct {
        http.ResponseWriter
        statusCode int
        body       *bytes.Buffer
}

// WriteHeader captures the status code
func (r *responseRecorder) WriteHeader(statusCode int) <span class="cov8" title="1">{
        r.statusCode = statusCode
        r.ResponseWriter.WriteHeader(statusCode)
}</span>

// Write captures the response body
func (r *responseRecorder) Write(b []byte) (int, error) <span class="cov8" title="1">{
        // Ensure the body buffer is initialized
        if r.body == nil </span><span class="cov8" title="1">{
                r.body = new(bytes.Buffer)
        }</span>

        // Write to the underlying response writer as well
        <span class="cov8" title="1">r.ResponseWriter.Write(b)

        return r.body.Write(b)</span>
}

// Reset clears the recorder for reuse
func (r *responseRecorder) Reset() <span class="cov8" title="1">{
        r.statusCode = http.StatusOK
        if r.body != nil </span><span class="cov8" title="1">{
                r.body.Reset()
        }</span> else<span class="cov0" title="0"> {
                r.body = new(bytes.Buffer)
        }</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package middleware

import (
        "context"
        "fmt"
        "net/http"
        "strings"

        "api-gateway/internal/config"
        "api-gateway/pkg/logger"

        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/codes"
        "go.opentelemetry.io/otel/exporters/jaeger"
        "go.opentelemetry.io/otel/propagation"
        "go.opentelemetry.io/otel/sdk/resource"
        sdktrace "go.opentelemetry.io/otel/sdk/trace"
        semconv "go.opentelemetry.io/otel/semconv/v1.16.0"
        "go.opentelemetry.io/otel/trace"
)

// TracingMiddleware provides distributed tracing functionality
type TracingMiddleware struct {
        config      *config.TracingConfig
        log         logger.Logger
        tracer      trace.Tracer
        tp          *sdktrace.TracerProvider
        initialized bool
}

// NewTracingMiddleware creates a new tracing middleware
func NewTracingMiddleware(config *config.TracingConfig, log logger.Logger) *TracingMiddleware <span class="cov8" title="1">{
        tm := &amp;TracingMiddleware{
                config: config,
                log:    log,
        }

        // Only initialize if tracing is enabled
        if config.Enabled </span><span class="cov8" title="1">{
                if err := tm.initialize(); err != nil </span><span class="cov0" title="0">{
                        log.Error("Failed to initialize tracing", logger.Error(err))
                }</span>
        }

        <span class="cov8" title="1">return tm</span>
}

// Initialize sets up the tracer provider
func (t *TracingMiddleware) initialize() error <span class="cov8" title="1">{
        // Create Jaeger exporter
        exp, err := jaeger.New(jaeger.WithCollectorEndpoint(jaeger.WithEndpoint(t.config.Endpoint)))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create tracer provider
        <span class="cov8" title="1">tp := sdktrace.NewTracerProvider(
                sdktrace.WithBatcher(exp),
                sdktrace.WithResource(resource.NewWithAttributes(
                        semconv.SchemaURL,
                        semconv.ServiceNameKey.String(t.config.ServiceName),
                )),
                sdktrace.WithSampler(sdktrace.TraceIDRatioBased(t.config.SampleRate)),
        )

        // Set global tracer provider
        otel.SetTracerProvider(tp)

        // Set global propagator
        otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(
                propagation.TraceContext{},
                propagation.Baggage{},
        ))

        // Create tracer
        t.tracer = tp.Tracer("api-gateway")
        t.tp = tp
        t.initialized = true

        t.log.Info("Tracing initialized",
                logger.String("provider", t.config.Provider),
                logger.String("endpoint", t.config.Endpoint),
                logger.String("service", t.config.ServiceName),
                logger.Any("sample_rate", t.config.SampleRate),
        )

        return nil</span>
}

// Tracing middleware adds distributed tracing to requests
func (t *TracingMiddleware) Tracing(next http.Handler) http.Handler <span class="cov8" title="1">{
        if !t.config.Enabled || !t.initialized </span><span class="cov8" title="1">{
                return next
        }</span>

        <span class="cov0" title="0">return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Extract context from request headers
                ctx := r.Context()
                ctx = otel.GetTextMapPropagator().Extract(ctx, propagation.HeaderCarrier(r.Header))

                // Start a new span
                spanName := r.Method + " " + r.URL.Path
                ctx, span := t.tracer.Start(ctx, spanName, trace.WithSpanKind(trace.SpanKindServer))
                defer span.End()

                // Add enhanced attributes to the span
                span.SetAttributes(
                        // Standard HTTP attributes
                        attribute.String("http.method", r.Method),
                        attribute.String("http.url", r.URL.String()),
                        attribute.String("http.scheme", r.URL.Scheme),
                        attribute.String("http.host", r.Host),
                        attribute.String("http.user_agent", r.UserAgent()),
                        attribute.String("http.flavor", r.Proto),
                        attribute.String("http.client_ip", r.RemoteAddr),

                        // Request specific attributes
                        attribute.String("request.path", r.URL.Path),
                        attribute.String("request.query", r.URL.RawQuery),

                        // API Gateway specific attributes
                        attribute.String("gateway.service", t.config.ServiceName),
                        attribute.Float64("gateway.sample_rate", t.config.SampleRate),
                )

                // Add request headers as attributes (excluding sensitive ones)
                for key, values := range r.Header </span><span class="cov0" title="0">{
                        // Skip sensitive headers
                        if !isSensitiveHeader(key) </span><span class="cov0" title="0">{
                                span.SetAttributes(attribute.String("http.header."+strings.ToLower(key), strings.Join(values, ",")))
                        }</span>
                }

                // Create a response writer that captures the status code
                <span class="cov0" title="0">recorder := &amp;responseRecorder{
                        ResponseWriter: w,
                        statusCode:     http.StatusOK,
                }

                // Process the request with the new context
                next.ServeHTTP(recorder, r.WithContext(ctx))

                // Add response attributes
                span.SetAttributes(
                        attribute.Int("http.status_code", recorder.statusCode),
                        attribute.String("http.status_text", http.StatusText(recorder.statusCode)),
                )

                // Mark as error if status code is 5xx
                if recorder.statusCode &gt;= 500 </span><span class="cov0" title="0">{
                        span.SetAttributes(attribute.Bool("error", true))
                        span.SetStatus(codes.Error, fmt.Sprintf("HTTP %d: %s", recorder.statusCode, http.StatusText(recorder.statusCode)))
                }</span>
        })
}

// isSensitiveHeader checks if a header is sensitive and should not be logged
func isSensitiveHeader(header string) bool <span class="cov8" title="1">{
        sensitiveHeaders := map[string]bool{
                "authorization":        true,
                "x-api-key":            true,
                "cookie":               true,
                "set-cookie":           true,
                "x-csrf-token":         true,
                "x-forwarded-for":      true,
                "proxy-authorize":      true,
                "proxy-authentication": true,
        }
        return sensitiveHeaders[strings.ToLower(header)]
}</span>

// Shutdown cleanly shuts down the tracer provider
func (t *TracingMiddleware) Shutdown(ctx context.Context) error <span class="cov8" title="1">{
        if t.config.Enabled &amp;&amp; t.initialized &amp;&amp; t.tp != nil </span><span class="cov0" title="0">{
                return t.tp.Shutdown(ctx)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package middleware

import (
        "net/http"
        "regexp"

        "api-gateway/internal/config"
        "api-gateway/pkg/logger"
)

// URLRewriter provides URL rewriting functionality
type URLRewriter struct {
        log logger.Logger
}

// NewURLRewriter creates a new URL rewriting middleware
func NewURLRewriter(log logger.Logger) *URLRewriter <span class="cov8" title="1">{
        return &amp;URLRewriter{
                log: log,
        }
}</span>

// Rewrite applies URL rewriting patterns to requests
func (u *URLRewriter) Rewrite(next http.Handler, rewriteConfig *config.URLRewrite) http.Handler <span class="cov8" title="1">{
        // Compile all regex patterns at initialization
        var patterns []*rewritePattern
        if rewriteConfig != nil </span><span class="cov8" title="1">{
                for _, p := range rewriteConfig.Patterns </span><span class="cov8" title="1">{
                        regex, err := regexp.Compile(p.Match)
                        if err != nil </span><span class="cov8" title="1">{
                                u.log.Error("Failed to compile URL rewrite pattern",
                                        logger.String("pattern", p.Match),
                                        logger.Error(err),
                                )
                                continue</span>
                        }
                        <span class="cov8" title="1">patterns = append(patterns, &amp;rewritePattern{
                                regex:       regex,
                                replacement: p.Replacement,
                        })</span>
                }
        }

        // If no valid patterns, just pass through
        <span class="cov8" title="1">if len(patterns) == 0 </span><span class="cov8" title="1">{
                return next
        }</span>

        <span class="cov8" title="1">return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                originalPath := r.URL.Path

                // Apply each rewrite pattern
                for _, pattern := range patterns </span><span class="cov8" title="1">{
                        if pattern.regex.MatchString(r.URL.Path) </span><span class="cov8" title="1">{
                                newPath := pattern.regex.ReplaceAllString(r.URL.Path, pattern.replacement)
                                r.URL.Path = newPath

                                u.log.Debug("URL rewritten",
                                        logger.String("original", originalPath),
                                        logger.String("rewritten", newPath),
                                )

                                // We only apply the first matching pattern
                                break</span>
                        }
                }

                <span class="cov8" title="1">next.ServeHTTP(w, r)</span>
        })
}

// rewritePattern represents a compiled rewrite pattern
type rewritePattern struct {
        regex       *regexp.Regexp
        replacement string
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
